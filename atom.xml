<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="zh-CN"><title type="text">poor guy</title><subtitle type="html">A Test Blog</subtitle><updated>2022-03-24T14:30:25+00:00</updated><id>https://poorguyorz.github.io/</id><link rel="alternate" type="text/html" href="https://poorguyorz.github.io/"/><link rel="self" type="application/atom+xml" href="https://poorguyorz.github.io/atom.xml"/><author><name>poor Guy</name><uri>https://poorguyorz.github.io/</uri><email>a_designer@qq.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><generator uri="https://gohugo.io/" version="0.92.1">Hugo</generator><entry><title type="text">面试</title><link rel="alternate" type="text/html" href="https://poorguyorz.github.io/posts/bigdata/log/"/><id>https://poorguyorz.github.io/posts/bigdata/log/</id><updated>2022-03-24T22:28:47+08:00</updated><published>2022-03-24T20:26:11+08:00</published><author><name>poor Guy</name><uri>https://poorguyorz.github.io/</uri><email>a_designer@qq.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">面试 只是一个技术汇总 C++基础 [2 days] [课程- https://github.com/parallel101/course.git] 内存 内存结构 c++ 编译出来的是可执行文件，是……</summary><content type="html">&lt;h1 id="面试">面试&lt;/h1>
&lt;p>只是一个技术汇总&lt;/p>
&lt;hr>
&lt;ul>
&lt;li>
&lt;p>C++基础 [2 days] [课程- https://github.com/parallel101/course.git]&lt;/p>
&lt;ul>
&lt;li>内存
&lt;ul>
&lt;li>
&lt;p>内存结构 &lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>c++ 编译出来的是可执行文件，是ELF格式的，他本来就有一些格式上的划分，C++在他的基础上进行了更细的划分，分为五个部分，从高地址到底地址依次为：&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>1. 内核虚拟内存&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>进程的虚拟印象&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>2. 栈&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>程序自动控制，具体为程序的函数调用，保存局部变量，有大小，可以使用ulimit -s 查看，也可以自行设置，但是建议系统默认即可&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>3. 共享库的内存印象&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>3. 堆&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>空间有程序员自行维护，向上增长(TIPS: 由于C的历史原因，C++的内存结构还是说堆区，但是在区别new/malloc 和delete/free 的时候，他们的差别之一可能会在内存上有点区别&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>C的malloc/free可能会说是在堆上分配空间，但是对于C++可能会说的是在自由存储区上分配，自由存储区和堆是不同的概念，堆是操作系统上的概念，但是自由存储区是一个抽象概念&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>一般new可以是在堆上分配空间，但是可能存在在其他情况，例如在栈上使用new，所以他们不是一个概念，面试的时候说到这里，可以装逼😎)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>4. 可写/全局区&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>对应elf中data段和bss段，data段保存的是已初始化的全局变量或者静态变量，bss保存的是未初始化的数据&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>5. 只读区&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>text段，保存编译之后的指令，不可变&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>6. 常量区&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>保存全局变量，不可变，rodata段，记得使用其他手段去尝试修改常量的时候会报错。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>7. 未使用&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/li>
&lt;li>
&lt;p>内存管理&lt;/p>
&lt;ul>
&lt;li>new
C++有对象的概念，所以他的new大意上是malloc的封装，先申请对象的内存空间，然后调用对象的构造函数构造对象，用在数组上是，先申请所有的空间，然后再依次调用构造函数&lt;/li>
&lt;li>delete
删除对象，先调用析构函数，然后再释放空间
&lt;ul>
&lt;li>对象数组
如果调用的是delete[]，如果是基础类型，则删除的时候使用delete和delete[] 都没有区别，因为空间连续的，有额外的空间记录内存的大小，直接使用delete的时候可以直接伤处 如果是自定义对象，如果有指针这类的属性，则必须调用delete[]，
否则他只会调用第一个对象的析构函数，可能会导致内存泄露&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&amp;ndash; new malloc 的区别&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>1. 空间分配的概念上&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>一个是堆区，一个是自由存储区&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>2. 使用上&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>new会调用构造函数，且new会自行计算对象所需的空间大小，malloc需要自行指定&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>3. 概念上&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>malloc是标准函数，而new是关键字&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/li>
&lt;li>
&lt;p>虚表&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.zhihu.com/question/389546003/answer/1194780618">实现&lt;/a>&lt;br>
虚表是多态的一种实现，但是不是C++的规定，而是编译器的自行的实现方法，在函数中只要声明虚函数，则对象中就会有额外的空间用于保存虚表，他是一个指针，指向虚表，所以对于有虚表的对象
sizeof的时候会计算这个指针的大小，指针指向虚表的第三个槽位，gdb查看地址的时候会显示+16的字样，因为这是实际的函数指针的开始位置，前两个槽位一个一般是0，拎一个一般是typeinfo的地址，
虚表和他的附属信息在内存中都是一起的，其实从根本原理上来说，他只是做了一层转换，实际上函数的调用最终的实现都是面向过程的函数的调用，函数才是C++ 的核心，
&lt;ul>
&lt;li>验证方法&lt;br>
编译的时候使用参数-fdump-lang-class，gdb调试的时候使用set print asm-demangle on，然后x/b打印地址&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>虚继承
同样使用到虚表，&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>智能指针&lt;/p>
&lt;/li>
&lt;li>
&lt;p>构造函数&lt;/p>
&lt;ul>
&lt;li>移动构造和移动赋值&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>右值&lt;/p>
&lt;/li>
&lt;li>
&lt;p>move&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>语法&lt;/li>
&lt;li>STL
&lt;ul>
&lt;li>容器
&lt;ul>
&lt;li>容器分类&lt;/li>
&lt;li>容器使用&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>迭代器
&lt;ul>
&lt;li>失效问题&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>算法&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>特性
&lt;ul>
&lt;li>11新特性&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>GDB
&lt;ul>
&lt;li>调试技巧&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>数据结构与算法 [3 天整理知识列表，长期进行]&lt;/p>
&lt;ul>
&lt;li>数据结构
&lt;ul>
&lt;li>树
&lt;ul>
&lt;li>二叉树&lt;/li>
&lt;li>红黑树&lt;/li>
&lt;li>234树&lt;/li>
&lt;li>树&lt;/li>
&lt;li>B+树&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>hash&lt;/li>
&lt;li>图&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>算法
&lt;ul>
&lt;li>二分&lt;/li>
&lt;li>dp&lt;/li>
&lt;li>排序&lt;/li>
&lt;li>dfs&lt;/li>
&lt;li>bfs&lt;/li>
&lt;li>&amp;hellip;&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>数据库 [3 天整理知识列表]&lt;/p>
&lt;ul>
&lt;li>编译
&lt;ul>
&lt;li>编译原理&lt;/li>
&lt;li>SQL编译过程&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>优化
&lt;ul>
&lt;li>优化规则&lt;/li>
&lt;li>CBO&lt;/li>
&lt;li>RBO&lt;/li>
&lt;li>优化框架
&lt;ul>
&lt;li>cascade&lt;/li>
&lt;li>遗传算法&lt;/li>
&lt;li>dp&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>执行
&lt;ul>
&lt;li>算子实现
&lt;ul>
&lt;li>join
&lt;ul>
&lt;li>merge join&lt;/li>
&lt;li>hash join&lt;/li>
&lt;li>nest loop join&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>sort&lt;/li>
&lt;li>窗口函数&lt;/li>
&lt;li>常规函数&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>执行框架
&lt;ul>
&lt;li>自底向上&lt;/li>
&lt;li>自顶向下&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>向量化&lt;/li>
&lt;li>codegen&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>存储
&lt;ul>
&lt;li>存储格式
&lt;ul>
&lt;li>行存&lt;/li>
&lt;li>列村&lt;/li>
&lt;li>index&lt;/li>
&lt;li>table&lt;/li>
&lt;li>partition&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>事务&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>案例
&lt;ul>
&lt;li>leveldb&lt;/li>
&lt;li>pg&lt;/li>
&lt;li>trafodion&lt;/li>
&lt;li>mysql&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>linux [2 天整理知识列表]&lt;/p>
&lt;ul>
&lt;li>进程，线程
&lt;ul>
&lt;li>通信&lt;/li>
&lt;li>内存结构&lt;/li>
&lt;li>IO&lt;/li>
&lt;li>多线程编程&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>网络 [1 天整理知识列表]&lt;/p>
&lt;/li>
&lt;li>
&lt;p>分布式 [2 天整理知识列表]&lt;/p>
&lt;ul>
&lt;li>共识协议
&lt;ul>
&lt;li>raft&lt;/li>
&lt;li>posie&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>大数据 [2 天整理知识列表]&lt;/p>
&lt;ul>
&lt;li>Hadoop&lt;/li>
&lt;li>spark&lt;/li>
&lt;li>hdfs&lt;/li>
&lt;li>hive&lt;/li>
&lt;li>scala&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>项目经历 [1 天整理知识列表]&lt;/p>
&lt;ul>
&lt;li>分区表&lt;/li>
&lt;li>临时表&lt;/li>
&lt;li>只读表&lt;/li>
&lt;li>bug fix&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></content><category scheme="https://poorguyorz.github.io/posts/" term="posts" label="posts"/></entry><entry><title type="text">现代C++白皮书</title><link rel="alternate" type="text/html" href="https://poorguyorz.github.io/posts/readbooks/%E7%8E%B0%E4%BB%A3c++%E7%99%BD%E7%9A%AE%E4%B9%A6/"/><id>https://poorguyorz.github.io/posts/readbooks/%E7%8E%B0%E4%BB%A3c++%E7%99%BD%E7%9A%AE%E4%B9%A6/</id><updated>2022-03-24T14:30:24+00:00</updated><published>2022-03-06T20:46:08+08:00</published><author><name>poor Guy</name><uri>https://poorguyorz.github.io/</uri><email>a_designer@qq.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">读者序 之前没有好好的阅读过一本任何技术书籍，一般都是打开前几张，然后慢慢的失去耐心，……</summary><content type="html">&lt;h2 id="读者序">读者序&lt;/h2>
&lt;p>之前没有好好的阅读过一本任何技术书籍，一般都是打开前几张，然后慢慢的失去耐心，所有造成的问题是一些书籍上的知识，只会对前面的章节有记忆，而大多数的书籍前面的章节也只是他书籍的入门介绍而已，所以我是个半吊子程序员，工作两年半之后，这个问题越来越困扰着我，有时候看见别人的面帖，感觉那些问题其实都因该是知道答案的，但是当我想要在脑海中把答案整理出来的时候却无从说起，简单的来说就是有的东西我是知道的，但是无法表示出来，不成体系，这给我一个错觉就是我感觉我能力可以，但是落到实地的时候却啥也做不了，脱离了谷歌百度或者其他我之前的资料，我啥都不行。&lt;/p>
&lt;p>我个人觉得问题的解决方式是学会输出，把自己的知识整理输出，通过自己让别人知道一项新技能，新知识，那就代表自己其实已经有了闹靠的基础，知识的输出需要一个载体，我不是老师，公司也没有这个渠道，因为公司的知识交流与工作内容是密切相关的，所以这也是我搭建这个博客的原因，但愿我可以长期的坚持下去，说实话，之前已经有了还几次类似的经历，但是都半途而废了，我希望这是最后一次&lt;/p>
&lt;h2 id="前言">前言&lt;/h2>
&lt;p>书籍是Bjarne Stroustup为HOPL所撰写的论文，目的是介绍c++在过去到现在的发展历程，以及其中一些大的功能点的演化。促发展上来划分C++可以分为两个阶段，一是C++98之前的类C版C++，二是之后的C++11之后的现代C++，在进40年的时间里C++还没有被取代，还可以在如此多的编程语言中占据一些之地，引用Bjarne Stroustup大佬的话说就是因为他填补了编程语言中一个重要的生态位。C++的核心是直接映射硬件和林开销抽象，&lt;/p>
&lt;ul>
&lt;li>
&lt;p>ISO
编程语言可以分为三种，一是有公司主导的编程语言，例如Google的go，C#以及苹果的swift等，二是由社区主导如php，python等，这两种在除了显而易见的好处之外的，都有各自的问题，公司主导的语言的，可能哎公司强势的时候还可以得到发展，但是公司没落之后，语言没有支持可能就无了，还有那家公司主导，那语言就是那家公司的产品，技术上的map由公司指定，小公司没有能力可以影响到语言的后续发展，对于社区，则可能会由于没有一个核心的个人或者组织来引导方向，导致语言偏离最初顶下的发展道路。Bjarne Stroustup就是基于以上的原因，提出组建一个标准委员会来引导C++ 的发展，&lt;/p>
&lt;/li>
&lt;li>
&lt;p>语言特性
具体的定义的语言的规则，有对应的具体的实现&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="1-起源">1. 起源&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>C++核心特性&lt;/p>
&lt;ol>
&lt;li>语言到设备之间的直接映射&lt;/li>
&lt;li>零开销抽象
&lt;ul>
&lt;li>不使用的东西就不需要付出任何代价&lt;/li>
&lt;li>使用到的东西就是可以实现的最好的&lt;/li>
&lt;li>抽象具体为类，函数，模板，概念和别名&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>simula
最早的面向对象的语言，之后几乎所有的面向对象的语言都是直接或者间接的受奥他的印象。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>C++最初是在1979年推出的，那时候是真正的带类的C。 Bjarne Stroustup的目的是想要一个可以直接映射硬件，同时又有类似于&lt;a href="https://baike.baidu.com/item/simula">simula&lt;/a>的具有抽象能力的语言，那是一个实验性质的语言的，实现就是把编码从C++逐行翻译到C，之后的1982年，随着人数的增加，他重写了前端，实现了一个功能完整的编译器，但是实际上在代码生成的是时候，还是生成的是C，&lt;/p>
&lt;p>之后就是平稳的发展到推出98版本的C++，不考虑最近的一些新特性的话，我们大部分人的C++ 知识就到这里了。此时C++实现了&lt;/p>
&lt;ul>
&lt;li>类&lt;/li>
&lt;li>多态&lt;/li>
&lt;li>运算符重载&lt;/li>
&lt;li>类型安全连接&lt;/li>
&lt;li>抽象类&lt;/li>
&lt;li>模板
更好的泛型编程。大佬最初的时候使用宏实现的泛型编程&lt;/li>
&lt;li>异常&lt;/li>
&lt;li>RAII&lt;/li>
&lt;li>*_cast&lt;/li>
&lt;li>bool&lt;/li>
&lt;li>STL标准库
上述就是最初的98的C++实现的功能点，实际上也是大多是C++的开发人员知道的最详细的C++知识。之后就是漫长过渡期，直到11版本的推出，使C++进入新时代，&lt;/li>
&lt;li>06年单核处理器新能几乎不再提升，所以大部分应用开始寻找可以提升性能的编程语言，&lt;/li>
&lt;/ul>
&lt;h2 id="c11-新时代">C++11 新时代&lt;/h2>
&lt;p>许多新的特性的引入，使得C++类似一个新语言
特性如下&lt;/p>
&lt;ul>
&lt;li>内存模型
高效的为现代硬件设计的底层抽象，描述并发的基础，&lt;/li>
&lt;li>auto|declytype&lt;/li>
&lt;li>range for
更好的遍历容器&lt;/li>
&lt;li>移动语义和右值引用&lt;/li>
&lt;li>统一初始化&lt;/li>
&lt;li>nullptrt&lt;/li>
&lt;li>constexpr&lt;/li>
&lt;li>用户自定义字面量&lt;/li>
&lt;li>原始字符串字面量&lt;/li>
&lt;li>属性&lt;/li>
&lt;li>lambda表达式&lt;/li>
&lt;li>变参模板&lt;/li>
&lt;li>模板别名&lt;/li>
&lt;li>noexcept&lt;/li>
&lt;li>override和final&lt;/li>
&lt;li>static_assert&lt;/li>
&lt;li>longlong&lt;/li>
&lt;li>默认成员初始化&lt;/li>
&lt;li>enum class&lt;/li>
&lt;/ul>
&lt;p>组件如下&lt;/p>
&lt;ul>
&lt;li>智能指针 unique_ptr和shared_ptr&lt;/li>
&lt;li>atomic&lt;/li>
&lt;li>thread库&lt;/li>
&lt;li>future，promise等&lt;/li>
&lt;li>tuple&lt;/li>
&lt;li>type trait&lt;/li>
&lt;li>正则&lt;/li>
&lt;li>随机数&lt;/li>
&lt;li>时间&lt;/li>
&lt;li>容器&lt;/li>
&lt;/ul>
&lt;p>上面的东西就是后续C++在98 的基础上推出的新11功能点，在我自己写这边文档的时候，其实有些东西我是没概念的😂，这些看似不相关的东西，可以分为下面的几个大的主题&lt;/p>
&lt;ol>
&lt;li>并发支持&lt;/li>
&lt;li>简化使用&lt;/li>
&lt;li>泛型编程的改进&lt;/li>
&lt;li>增加静态类型的安全&lt;/li>
&lt;li>支持对库的开发&lt;/li>
&lt;li>标准库组件&lt;/li>
&lt;/ol>
&lt;h3 id="1-并发支持">1. 并发支持&lt;/h3></content><category scheme="https://poorguyorz.github.io/posts/" term="posts" label="posts"/><category scheme="https://poorguyorz.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" term="读书笔记" label="读书笔记"/><category scheme="https://poorguyorz.github.io/tags/c-/" term="C++" label="C++"/></entry><entry><title type="text">Envs</title><link rel="alternate" type="text/html" href="https://poorguyorz.github.io/posts/others/envs/"/><id>https://poorguyorz.github.io/posts/others/envs/</id><updated>2022-03-24T22:28:47+08:00</updated><published>2022-02-21T19:00:25+08:00</published><author><name>poor Guy</name><uri>https://poorguyorz.github.io/</uri><email>a_designer@qq.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">hugo wget https://github.com/gohugoio/hugo/releases/download/v0.92.1/hugo_0.92.1_Linux-64bit.deb https://github.91chi.fun/https://github.com//gohugoio/hugo/releases/download/v0.92.2/hugo_extended_0.92.2_Linux-64bit.deb sudo dpkg -i hugo*.deb 140.82.113.3 aria2c -s 5 https://github.com/gohugoio/hugo/releases/download/v0.92.1/hugo_0.92.1_Linux-64bit.deb https://github.com/gohugoio/hugo/releases/download/v0.92.1/hugo_0.92.1_Linux-64bit.deb 可以使用aria2下载，ubuntu使用apt install aria……</summary><content type="html">&lt;h2 id="hugo">hugo&lt;/h2>
&lt;p>wget &lt;a href="https://github.com/gohugoio/hugo/releases/download/v0.92.1/hugo_0.92.1_Linux-64bit.deb">https://github.com/gohugoio/hugo/releases/download/v0.92.1/hugo_0.92.1_Linux-64bit.deb&lt;/a>
&lt;a href="https://github.91chi.fun/https://github.com//gohugoio/hugo/releases/download/v0.92.2/hugo_extended_0.92.2_Linux-64bit.deb">https://github.91chi.fun/https://github.com//gohugoio/hugo/releases/download/v0.92.2/hugo_extended_0.92.2_Linux-64bit.deb&lt;/a>
sudo dpkg -i hugo*.deb&lt;/p>
&lt;p>140.82.113.3&lt;/p>
&lt;p>aria2c -s 5 &lt;a href="https://github.com/gohugoio/hugo/releases/download/v0.92.1/hugo_0.92.1_Linux-64bit.deb">https://github.com/gohugoio/hugo/releases/download/v0.92.1/hugo_0.92.1_Linux-64bit.deb&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://github.com/gohugoio/hugo/releases/download/v0.92.1/hugo_0.92.1_Linux-64bit.deb">https://github.com/gohugoio/hugo/releases/download/v0.92.1/hugo_0.92.1_Linux-64bit.deb&lt;/a>&lt;/p>
&lt;p>可以使用aria2下载，ubuntu使用&lt;code>apt install aria2&lt;/code>直接安装工具，使用-s开启多路下载
aria2c -s 5 &lt;a href="https://github.com/gohugoio/hugo/releases/download/v0.92.1/hugo_0.92.1_Linux-64bit.deb">https://github.com/gohugoio/hugo/releases/download/v0.92.1/hugo_0.92.1_Linux-64bit.deb&lt;/a>&lt;/p>
&lt;p>manager用户&lt;/p>
&lt;p>&lt;a href="https://www.jianshu.com/p/a76a93e8c662">https://www.jianshu.com/p/a76a93e8c662&lt;/a>&lt;/p>
&lt;h2 id="unix">Unix&lt;/h2>
&lt;p>分区问题，集群上多块磁盘分区挂载到指定目录&lt;/p>
&lt;pre tabindex="0">&lt;code>fdisk disk 可以对一个磁盘进行分区的添加和删除等操作
p
d
w
h
&lt;/code>&lt;/pre>&lt;p>添加磁盘挂载&lt;/p>
&lt;pre tabindex="0">&lt;code>lsblk -f 查看磁盘
mkfs.xfs -f -n ftype=1 /dev/sdb1 格式化磁盘
mount /dev/sdb1 /var/lib/docker 挂载
xfs_info /dev/sdb1 | grep ftype=1
blkid /dev/sdb1 查看UUID
UUID=&amp;lt;UUID&amp;gt; /var/lib/docker xfs defaults 0 0 写进/etc/fstab
&lt;/code>&lt;/pre>&lt;p>问题&lt;code>Couldn't find device with uuid 4mhUbb-Ls1h-jp0d-JuJK-C38V-T3tX-f7s2IN&lt;/code>&lt;/p>
&lt;p>原因未知，疑似但是这个UUID是前面挂载的分区格式化之前的UUID，所以可能是挂载的时候出了什么问题，但是之前对其他机器操作无问题，此问题只出现在集群中的一两太机器上。&lt;/p>
&lt;p>解决：&lt;/p>
&lt;pre tabindex="0">&lt;code>使用 vgreduce --removemissing --verbose lvname 解决，但是需要视情况而定，需要知道自己在做什么
其中会使用的命令
lsblk
vgscan
pvscan
cat /etc/lvm/archive/* | less 查看UUID和盘符之前的关系
lvextend -L +300G /dev/mapper/centos-root 扩展分区大小
xfs_growfs /dev/mapper/centos-root 扩展且生效
lvremove /dev/mapper/centos-home 删除lv
lvcreate -L 100G -n /dev/mapper/centos-home 创建lv
mkdf.sfx /xxxx 创建文件系统
&lt;/code>&lt;/pre>&lt;p>详细储备知识 &lt;a href="https://blog.csdn.net/lemontree1945/article/details/79293390">linux 文件&lt;/a>&lt;/p>
&lt;h2 id="ubuntu安装typora">Ubuntu安装typora&lt;/h2>
&lt;p>上海无法直连外网，所以这些都需要翻墙，或者使用其他的链接方式，&lt;/p>
&lt;ol>
&lt;li>直接使用snap安装，一般情况下，Ubuntu上可以使用apt安装就使用apt安装，这样节约空间，但是无法使用apt的时候，可以尝试使用snap，不是首选，但是无法链接网络的时候，这是首选方案&lt;/li>
&lt;li>使用安装包，但是可能无法下载&lt;/li>
&lt;li>添加typora的apt源，使用apt下载，可能有网络问题&lt;/li>
&lt;/ol>
&lt;h2 id="kubelet-换包">kubelet 换包&lt;/h2>
&lt;p>&lt;a href="http://docs.kubernetes.org.cn/227.html">官网&lt;/a>&lt;/p>
&lt;h3 id="角色">角色&lt;/h3>
&lt;ul>
&lt;li>deployment
*&lt;/li>
&lt;li>replicaset&lt;/li>
&lt;li>pod&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>docker pull 172.16.1.99/postcommit/inceptor@sha256:d9a8c9c1cf4e1587e2ac468942a987ee43b92c99787f9d392b81a8e1bda26932
docker tag 3b2a1923a5d3 baisheng5:5000/transwarp/argodb-inceptor:argodb-3.2.0-final-wl
docker push baisheng5:5000/transwarp/argodb-inceptor:argodb-3.2.0-final-wl
vdevelop-shiva1-202112141040
kubectl get deployment | grep shiva
172.16.1.99/postcommit/shiva-tabletserver:vdevelop-shiva1-202112141040
172.16.1.99/postcommit/shiva-master:vdevelop-shiva1-202112141040
172.16.1.99/postcommit/shiva-webserver:vdevelop-shiva1-202112141040
&lt;/code>&lt;/pre>&lt;p>改变deployment的配置文件的镜像，他会自动重启然后拉取镜像启动服务，所以需要准备自己的镜像，一般只需要替换镜像中的一个或者几个文件，然后让k8s使用此镜像即可，但是无法直接替换镜像中的文件，需要在运行的容器中替换，然后再以此为基准建立新的镜像，然后替换&lt;/p>
&lt;p>安装最新gcc g++
&lt;a href="https://www.jianshu.com/p/">https://www.jianshu.com/p/&lt;/a>
&lt;a href="https://cloud.tencent.com/developer/article/1635218">https://cloud.tencent.com/developer/article/1635218&lt;/a>&lt;/p>
&lt;h2 id="ubuntu换源">Ubuntu换源&lt;/h2>
&lt;pre tabindex="0">&lt;code>cd /etc/apt/
sudo cp sources.list sources.list.bak
sudo vim sources.list
注意换源的版本
deb http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse
deb-src http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse
deb http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse
deb-src http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse
deb http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse
deb-src http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse
deb http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse
deb-src http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse
deb http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse
deb-src http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse
sudo apt-get update
sudo apt-get upgrade
&lt;/code>&lt;/pre>&lt;pre tabindex="0">&lt;code>sudo add-apt-repository ppa:ubuntu-toolchain-r/test
sudo apt update
sudo apt install g++-11
sudo apt install gcc-11
&lt;/code>&lt;/pre>&lt;p>export GIT_CURL_VERBOSE=1
github无法使用https拉取代码&lt;/p>
&lt;ul>
&lt;li>单机docker换源，编辑/etc/docker/daemon.json，配置为&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>{
&amp;quot;registry-mirrors&amp;quot;: [&amp;quot;https://docker.mirrors.ustc.edu.cn/&amp;quot;]
}
&lt;/code>&lt;/pre>&lt;p>然后使用systemctl daemon-reload重新加载配置，使用systemctl restart docker重启docker即可&lt;/p>
&lt;p>改变deployment的配置文件的镜像，他会自动重启然后拉取镜像启动服务，所以需要准备自己的镜像，一般只需要替换镜像中的一个或者几个文件，然后让k8s使用此镜像即可，但是无法直接替换镜像中的文件，需要在运行的容器中替换，然后再以此为基准建立新的镜像，然后替换&lt;/p>
&lt;h2 id="mysql">mysql&lt;/h2>
&lt;ul>
&lt;li>安装&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>sudo apt install mysql-server
mysql_secure_installation
&lt;/code>&lt;/pre>&lt;p>密码问题&lt;/p>
&lt;pre tabindex="0">&lt;code>/etc/mysql/mysql.conf.d/mysqld.cnf/
添加
skip-grant-tables
然后使用mysql进入mysql
主要修改user下的用户的密码字段
无法直接使用update语句，
可以使用ALTER USER 'root'@'localhost' IDENTIFIED BY '123456'; 修改
如果报权限问题，使用flush privileges;刷新在执行
之后再修改配置文件去掉添加的信息即可
密码策略，
SHOW VARIABLES LIKE 'validate_password%';查看密码策略
使用set global validate_password_length=6;修改策略
&lt;/code>&lt;/pre></content><category scheme="https://poorguyorz.github.io/posts/" term="posts" label="posts"/></entry><entry><title type="text">Docker</title><link rel="alternate" type="text/html" href="https://poorguyorz.github.io/posts/others/docker/"/><id>https://poorguyorz.github.io/posts/others/docker/</id><updated>2022-03-24T22:28:47+08:00</updated><published>2022-02-20T21:17:58+08:00</published><author><name>poor Guy</name><uri>https://poorguyorz.github.io/</uri><email>a_designer@qq.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">Docker 新公司的产品的每一个模块是单独运行在容器中的，且由于是使用Java开发的，所以需要……</summary><content type="html">&lt;h2 id="docker">Docker&lt;/h2>
&lt;p>新公司的产品的每一个模块是单独运行在容器中的，且由于是使用Java开发的，所以需要有频繁替换包的过程，之前只是简单的了解了docker，但是并没有深入的学习，这里记录docker的使用细节，以便于更好的工作，&lt;/p>
&lt;h2 id="基础概念">基础概念&lt;/h2>
&lt;p>Docker使用go开发的一种沙箱工具，他使得应用可以单独运行在沙箱中，通过端口映射或者volumes与外界进行交互。这可以让一个机器上可以运行多种不同环境的应用且互不干扰，例如一个比较大型的引用，使用的此方式单独维护一个模块，使得系统的可靠性大大增强&lt;/p>
&lt;ul>
&lt;li>容器&lt;br>
镜像运行的实例，一个镜像可以运行多个实例。&lt;/li>
&lt;li>镜像&lt;br>
一个完整的可运行的资源集合&lt;/li>
&lt;li>仓库&lt;br>
保存镜像&lt;/li>
&lt;/ul>
&lt;h2 id="使用">使用&lt;/h2>
&lt;p>这里记录高频次使用的功能，其他的后续记录&lt;/p>
&lt;ul>
&lt;li>
&lt;p>镜像的管理&lt;/p>
&lt;ul>
&lt;li>pull&lt;/li>
&lt;li>push&lt;/li>
&lt;li>commit&lt;br>
修改一个容器之后，使用commit在此基础上构建自己的容器&lt;/li>
&lt;li>build&lt;br>
创建一个镜像，使用docker build语句创建，需要自己编写Dockerfile，具体的编写规则可以参考nosipage&lt;/li>
&lt;li>rmi&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>容器的管理&lt;/p>
&lt;ul>
&lt;li>run&lt;br>
创建新的容器，且会使用run指定启动规则，例如端口的映射，volumes文件的指定，以及其他重要参数等，这个命令可以说重要，因为同一个镜像，使用不同参数启动之后，效果是不一样的，对于开发来时，更多的是参与后期的开发，如果不是前期的项目设计，这里了解即可，但是最好的是知道他的只要参数的意义，因为和其他命令有的是通用的，例如-i -t -p等&lt;/li>
&lt;li>start&lt;/li>
&lt;li>stop&lt;/li>
&lt;li>restart&lt;/li>
&lt;li>exec&lt;br>
使用此命令可以进入运行中的容器中区，exec -it xxx command&lt;/li>
&lt;li>attach&lt;/li>
&lt;li>rm&lt;/li>
&lt;li>logs&lt;/li>
&lt;li>cp&lt;br>
在本地和容器中传输文件&lt;/li>
&lt;li>export&lt;/li>
&lt;li>ps&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>其他命令基本在遇到的时候，再去查看&lt;/p></content><category scheme="https://poorguyorz.github.io/posts/" term="posts" label="posts"/><category scheme="https://poorguyorz.github.io/tags/docker/" term="Docker" label="Docker"/></entry><entry><title type="text">C++ logs</title><link rel="alternate" type="text/html" href="https://poorguyorz.github.io/posts/languange/cpp/"/><id>https://poorguyorz.github.io/posts/languange/cpp/</id><updated>2022-03-24T22:28:47+08:00</updated><published>2022-02-20T20:54:01+08:00</published><author><name>poor Guy</name><uri>https://poorguyorz.github.io/</uri><email>a_designer@qq.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">编译器 把高级语言编译成可执行语言工具，分为前端后后端，前端值得是高级语言的解析，后端……</summary><content type="html">&lt;h1 id="编译器">编译器&lt;/h1>
&lt;p>把高级语言编译成可执行语言工具，分为前端后后端，前端值得是高级语言的解析，后端是指翻译解析之后的结果为机器语言&lt;/p>
&lt;ul>
&lt;li>
&lt;p>多文件
** 连接
多文件编译可以有两种方式，一是直接编译为一个可以执行文件，二是按模块或者按文件编译为库，然后连接到执行文件&lt;/p>
&lt;ul>
&lt;li>连接方式有两种，
一是静态连接，把所有的库文件打包到最后的生成文件中，优点是不需要额外的依赖外部环境，独立性强，缺点是文件体积大
二是动态链接，为了解决静态链接的缺点，执行文件在执行到库相关的代码的时候才加载库，有一点需要注意的是，程序运行的时候，在使用到动态库的时候才映射动态库到内存空间中。原理是编译待援在编译的时候，会更具声明生成函数的调用逻辑，但是只是一个地址跳转语句，所以，只要不调用，就不会有问题，当调用到了。才会加载库然后映射库的地址，这个完整的过程称为重定向。
&lt;a href="https://joytsing.github.io/posts/59293/">动态连接&lt;/a>
&lt;a href="https://www.bookstack.cn/read/open-c-book/doc-README.md">C语言编程透视&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>声明
声明是为了在编译的时候编译器能进行完整的上下文编译。他需要更具声明来确定编译信息，否则编译器无法确定编译中的语句信息，声明可以辅助完成这个情况， 所以理论上编译的时候是可以不需要实现的，可以在其他编译单元中实现声明的函数，其声明的文件可以不引用头文件，即两个编译单元完全可以无任何联系，除了声明之外，在连接的时候，连接器会根据编译出来的信息去确定函数调用情况，这里有一个问题，按上述的描述，是一个声明对应一个实现，如果有一个声明对应多个实现呢
== ： 会有覆盖问题，如果多个动态链接库都有同一个声明的实现，则连接的时候连接第一个，后面的则忽略，这也提醒我们，在大型项目中，避免同名全局函数或者变量，使用namespace或者static限制作用域，&lt;/p>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c++" data-lang="c++">&lt;span class="n">g&lt;/span>&lt;span class="o">++&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="n">o&lt;/span> &lt;span class="n">tt&lt;/span> &lt;span class="p">..&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">main&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">cpp&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="n">ldl&lt;/span> &lt;span class="p">.&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">libhellolib&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">so&lt;/span> &lt;span class="p">.&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">libhellolib1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">so&lt;/span>
&lt;span class="n">LD_LIBRARY_PATH&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="err">$&lt;/span>&lt;span class="n">PWD&lt;/span> &lt;span class="p">.&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">tt&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>头文件，避免公用代码的重复，预处理时展开头文件，需要使用#pragma once避免重复引用，头文件只是简单的文件替换，理论上的可以替换任何文本。&lt;/li>
&lt;/ul>
&lt;p>cmake
* 子模块，使用add_subdirectory引入
* 第三方库
* 只是头文件，直接指定头文件目录编译即可
* 使用子模块
* 使用为连接库
* 使用git模块&lt;/p>
&lt;ul>
&lt;li>
&lt;p>STL&lt;/p>
&lt;ul>
&lt;li>重点为容器和算法&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>lambda表达式，实质上是仿函数，是一个结构体实现()运算的重载，捕获的时候按照声明的新式捕获参数，建议使用的时候明确使用的参数，使用哪个就捕获哪一个，否则他实际上会占据一定的大小的，配合std::function使用&lt;/p>
&lt;/li>
&lt;li>
&lt;p>CTAD &amp;mdash; complie-time argument deduction，编译器参数推断，C++17引入的，可以在编译器按照上下文推断类型，具体表现在lambda参数可以使用auto，容器可以不适用&amp;lt;&amp;gt;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>ranges
&lt;a href="https://zhuanlan.zhihu.com/p/350068132">https://zhuanlan.zhihu.com/p/350068132&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>module&lt;/p>
&lt;/li>
&lt;li>
&lt;p>raii 获取资源即初始化，释放资源即销毁，具体的实现是使用构造函数和析构函数，当前的实现为智能指针，其他用户自己管理的资源最好也使用raii，遮这样在函数有多个出口的时候，就不会有意外的情况，本质上还是自己管理资源，不想其他的语言有GC&lt;/p>
&lt;ul>
&lt;li>异常安全，C++中异常机制在回溯栈的时候会析构对象，所以如果没有实现RAII，则自己管理的内存则无法释放，C++的异常可以发生在任何地方，如果发生在析构函数中，则需要自己处理，不要在析构函数中抛出异常的，在构造函数中的时候，也需要捕获异常然后释放已经申请的资源，构造函数异常的时候，是不会调用析构函数的，&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>构造函数&lt;/p>
&lt;ul>
&lt;li>构造函数有时候会隐士的生成对象，即使没有显示声明，使用explicit避免这种情况，单参数的时候会，多参数使用{}，调用的时候也会
&lt;ul>
&lt;li>直接使用多参数的时候，()和{}是有区别的，()除了正常的使用外，其他情况不具备特殊含义&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c++" data-lang="c++"> &lt;span class="kt">int&lt;/span> &lt;span class="n">a&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="mi">10&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">11&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">a&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="mi">10&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">11&lt;/span>&lt;span class="p">};&lt;/span>
&lt;span class="n">tt&lt;/span> &lt;span class="nf">t&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ul>
&lt;p>tt q{1, 3};
tt w = {1, 4};
tests({1,5});
```
上面的语句1正确，a的值为11，2错误，{}这种用法的意义是参数列表，是会构造对象的。ps，调用构造函数的时候，有具体的对象的时候两种括号无差别，但是无对象的时候有区别，如上，细品&lt;/p>
&lt;ul>
&lt;li>默认构造函数&lt;/li>
&lt;li>拷贝构造( A(A const &amp;amp; a) ) A a = aa;&lt;/li>
&lt;li>移动构造( A(A &amp;amp;&amp;amp; a) )&lt;/li>
&lt;li>赋值构造( A&amp;amp;operator=(A const&amp;amp; a) ) A a; a = aa;&lt;/li>
&lt;li>移动赋值( A&amp;amp;operator=(A &amp;amp;&amp;amp; a) )&lt;/li>
&lt;li>=delte和=default&lt;/li>
&lt;li>类内部变量可以赋初值&lt;/li>
&lt;li>三五法则
&lt;ul>
&lt;li>拷贝构造或者赋值构造需要区分深拷贝和浅拷贝，这也是构造函数肯可能引入的问题，例如浅拷贝导致内存的重复释放，&lt;/li>
&lt;li>各种构造函数更多的是需要考虑当前对象的来源，如果是直接从零开始的，则是普通的构造函数，如果是从别的对象来的，则需要考虑深浅拷贝的问题，以及构造之后别的对象是否还需要的问题，简而言之，就是资源细节上的考虑，只要内涉及到资源的操作，则需要多话费一些心思区考虑，&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>函数返回多值&lt;/p>
&lt;ul>
&lt;li>使用结构体打包，结构体可以使用{}任意构造，且好处是可以获取变量的名字&lt;/li>
&lt;li>tuple&lt;/li>
&lt;li>pair&lt;/li>
&lt;li>各种结构方式&lt;/li>
&lt;li>结构化绑定，类似rust&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>option 成功则优质返回，否则返回nullopt，搭配has_value等使用，类似rust&lt;/p>
&lt;/li>
&lt;li>
&lt;p>variant&lt;/p>
&lt;/li>
&lt;li>
&lt;p>智能指针&lt;/p>
&lt;ul>
&lt;li>RAII的具体体现&lt;/li>
&lt;li>unique_ptr
禁止拷贝，只允许移动，避免产生多个对象&lt;/li>
&lt;li>shared_ptr
使用计数器记录对象，允许存在多个对象，相互引用问题，&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>限于篇幅，此处放出一些扩展知识供学有余力的同学研究：
P-IMPL 模式
虚函数与纯虚函数
拷贝如何作为虚函数
std::unique_ptr::release()
std::enable_shared_from_this
dynamic_cast
std::dynamic_pointer_cast
运算符重载
右值引用 &amp;amp;&amp;amp;
std::shared_ptr&lt;void>和 std::any
只提供了关键字，详细信息请善用搜索引擎：bing.com。（不要用 baidu.com，那个是搜广告用的）
如果感兴趣，我可以增添一节专门讲动态多态。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>模板&lt;/p>
&lt;ul>
&lt;li>更加广义上的重载机制，模板会在编译的时候，在依据上下文信息编译代码，调用的时候可以使用&amp;lt;&amp;gt;声明模板参数，在17之后有CTAD，可以省略这一步，直接和调用普通函数一致，但是需要明确的是他是需要从上下文进行类型的推到，如果编译时上下文无法推到类型信息，则还是需要使用尖括号，&lt;/li>
&lt;li>模板可以是CLASS或者typename，也可以是整形，例如tuple的get函数使用整形模板参数指定参数index，但是参数只能是整形，不知道是从哪里开的口子，
&lt;ul>
&lt;li>此时模板参数必须是编译期间可以确定的常量，如果是表达式，可以使用constexpri修饰，&lt;/li>
&lt;li>使用整形的一个特殊原因是由于模板参数是编译器编译期间可以确定的，则此时可以根据模板参数进行代码优化，例如函数的参数列表使用bool确定函数是否是debug模式，此时由于参数是变量，所以无法优化，必须有一个if跳转逻辑。但是假如是模板参数，则会在编译的时候确定生成的代码是什么，可以直接在代码生成的时候优化掉&lt;/li>
&lt;li>编译期常量，是编译器在编译期间的可以通过直接运算或者其他方式运算得到一个确切的值，需要使用constexpr修饰，否则即使是一个值，他也不能用在有要求的地方，例如模板参数&lt;/li>
&lt;li>模板的惰性编译，
&lt;ul>
&lt;li>模板会工具编译时候遇到的模板参数生成不同的函数，函数名字的参数类型不一样，具体可以使用objdump查看生成的函数名，所以一个模板可能有多份代码的生成，需要考虑实际的使用情况，如果一个模板没有使用到，此时他的模板参数按什么生成，所以模板是在遇到调用的时候才生成的，是惰性的，此过程隐含两个信息，一是编译的时候需要调用才生成代码，二是编译的时候能找到模板的说明代码，因为编译是分为不同的编译单元的，如果在编译模板的编译单元的时候没有发现模板调用，导致没有生成代码，其他的编译单元发现了调用，但是模板的编译单元已编译完成，所以模板需要注意的是使用的时候最好确保所有的使用的代码都能看见模板实现，简单的就是模板最好放在头文件实现，不要分开。否则需要在模板的编译单元里面添加模板参数的声明。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>auto只是推到类型，不包含引用信息和const，可以手动指定&lt;/p>
&lt;/li>
&lt;li>
&lt;p>if constexpr&lt;/p>
&lt;/li>
&lt;li>
&lt;p>int&amp;amp; int&amp;amp;&amp;amp; const int &amp;amp;&lt;/p>
&lt;ul>
&lt;li>常饮用范围最小，其他两种引用都可以转换为长应用&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></content><category scheme="https://poorguyorz.github.io/posts/" term="posts" label="posts"/><category scheme="https://poorguyorz.github.io/tags/test_tag/" term="test_tag" label="test_tag"/><category scheme="https://poorguyorz.github.io/tags/asd/" term="asd" label="asd"/></entry><entry><title type="text">Hello World</title><link rel="alternate" type="text/html" href="https://poorguyorz.github.io/posts/others/hello-world/"/><id>https://poorguyorz.github.io/posts/others/hello-world/</id><updated>2022-03-24T22:28:47+08:00</updated><published>2022-02-07T03:54:01+08:00</published><author><name>poor Guy</name><uri>https://poorguyorz.github.io/</uri><email>a_designer@qq.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.
Quick Start Create a new post 1 $ hexo new &amp;#34;My New Post&amp;#34; More info: Writing</summary><content type="html">&lt;p>Welcome to &lt;a href="https://hexo.io/">Hexo&lt;/a>! This is your very first post. Check &lt;a href="https://hexo.io/docs/">documentation&lt;/a> for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href="https://hexo.io/docs/troubleshooting.html">troubleshooting&lt;/a> or you can ask me on &lt;a href="https://github.com/hexojs/hexo/issues">GitHub&lt;/a>.&lt;/p>
&lt;h2 id="quick-start">Quick Start&lt;/h2>
&lt;h3 id="create-a-new-post">Create a new post&lt;/h3>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">$ hexo new &lt;span class="s2">&amp;#34;My New Post&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>More info: &lt;a href="https://hexo.io/docs/writing.html">Writing&lt;/a>&lt;/p>
&lt;h3 id="run-server">Run server&lt;/h3>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">$ hexo server
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>More info: &lt;a href="https://hexo.io/docs/server.html">Server&lt;/a>&lt;/p>
&lt;!-- more -->
&lt;h3 id="generate-static-files">Generate static files&lt;/h3>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">$ hexo generate
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>More info: &lt;a href="https://hexo.io/docs/generating.html">Generating&lt;/a>&lt;/p>
&lt;h3 id="deploy-to-remote-sites">Deploy to remote sites&lt;/h3>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">$ hexo deploy
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>More info: &lt;a href="https://hexo.io/docs/one-command-deployment.html">Deployment&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c++" data-lang="c++">&lt;span class="n">sssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="nf">main&lt;/span> &lt;span class="p">();&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>$f(x) = a+b$&lt;/p>
&lt;p>​
This is my first post on the site. I hope that you like it!
​&lt;/p>
&lt;h2 id="welcome-function">Welcome Function&lt;/h2>
&lt;p>​
Here is a little Python function to welcome you:
​
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="k">def&lt;/span> &lt;span class="nf">hello_world&lt;/span>&lt;span class="p">():&lt;/span>
&lt;span class="nb">print&lt;/span> &lt;span class="s2">&amp;#34;Hello there!&amp;#34;&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="k">def&lt;/span> &lt;span class="nf">hello_world&lt;/span>&lt;span class="p">():&lt;/span>
&lt;span class="nb">print&lt;/span> &lt;span class="s2">&amp;#34;Hello there!&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div></content><category scheme="https://poorguyorz.github.io/posts/" term="posts" label="posts"/><category scheme="https://poorguyorz.github.io/tags/test_tag/" term="test_tag" label="test_tag"/><category scheme="https://poorguyorz.github.io/tags/asd/" term="asd" label="asd"/></entry></feed>