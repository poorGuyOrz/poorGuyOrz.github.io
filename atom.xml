<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="zh-CN"><title type="text">poor guy</title><subtitle type="html">A Test Blog</subtitle><updated>2022-05-15T14:37:52+00:00</updated><id>https://poorguyorz.github.io/</id><link rel="alternate" type="text/html" href="https://poorguyorz.github.io/"/><link rel="self" type="application/atom+xml" href="https://poorguyorz.github.io/atom.xml"/><author><name>poor Guy</name><uri>https://poorguyorz.github.io/</uri><email>a_designer@qq.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><generator uri="https://gohugo.io/" version="0.92.1">Hugo</generator><entry><title type="text">LevelDB源码阅读</title><link rel="alternate" type="text/html" href="https://poorguyorz.github.io/posts/readbooks/leveldb/"/><id>https://poorguyorz.github.io/posts/readbooks/leveldb/</id><updated>2022-05-15T22:37:28+08:00</updated><published>2022-05-15T21:59:53+08:00</published><author><name>poor Guy</name><uri>https://poorguyorz.github.io/</uri><email>a_designer@qq.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">之前有零碎的阅读代码，但是没有整理，此次花费两天的时间整理整个项目 主要组件 slice 字符串的……</summary><content type="html">&lt;blockquote>
&lt;p>之前有零碎的阅读代码，但是没有整理，此次花费两天的时间整理整个项目&lt;/p>
&lt;/blockquote>
&lt;h2 id="主要组件">主要组件&lt;/h2>
&lt;h3 id="slice">slice&lt;/h3>
&lt;p>字符串的浅拷贝实现，使用一个指针和指针长度实现，类似c++后来实现的string_view，如果使用string，则在传递数据的时候会进行拷贝操作，有性能损失。另一个目的是为了自主可控，简单的实现利于数据的血缘追踪&lt;/p>
&lt;h3 id="status">status&lt;/h3>
&lt;p>自定义信息模块，把状态码和状态信息进行压缩，压缩格式如下&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c++" data-lang="c++">&lt;span class="n">Status&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">Status&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">Code&lt;/span> &lt;span class="n">code&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">const&lt;/span> &lt;span class="n">Slice&lt;/span>&lt;span class="o">&amp;amp;&lt;/span> &lt;span class="n">msg&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">const&lt;/span> &lt;span class="n">Slice&lt;/span>&lt;span class="o">&amp;amp;&lt;/span> &lt;span class="n">msg2&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="n">assert&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">code&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="n">kOk&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="k">const&lt;/span> &lt;span class="kt">uint32_t&lt;/span> &lt;span class="n">len1&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">static_cast&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">uint32_t&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">msg&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">size&lt;/span>&lt;span class="p">());&lt;/span>
&lt;span class="k">const&lt;/span> &lt;span class="kt">uint32_t&lt;/span> &lt;span class="n">len2&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">static_cast&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">uint32_t&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">msg2&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">size&lt;/span>&lt;span class="p">());&lt;/span>
&lt;span class="k">const&lt;/span> &lt;span class="kt">uint32_t&lt;/span> &lt;span class="n">size&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">len1&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">len2&lt;/span> &lt;span class="o">?&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="mi">2&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">len2&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">:&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="kt">char&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">result&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="kt">char&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">size&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">5&lt;/span>&lt;span class="p">];&lt;/span>
&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">memcpy&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">result&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">size&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">sizeof&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">size&lt;/span>&lt;span class="p">));&lt;/span>
&lt;span class="n">result&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">4&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">static_cast&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">char&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">code&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">memcpy&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">result&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">5&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">msg&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">data&lt;/span>&lt;span class="p">(),&lt;/span> &lt;span class="n">len1&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">len2&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="n">result&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">5&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">len1&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="sc">&amp;#39;:&amp;#39;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">result&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">6&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">len1&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="sc">&amp;#39; &amp;#39;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">memcpy&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">result&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">7&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">len1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">msg2&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">data&lt;/span>&lt;span class="p">(),&lt;/span> &lt;span class="n">len2&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="n">state_&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">result&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="编码">编码&lt;/h3>
&lt;p>leveldb中几乎所有的数据都会和数据格式的编码或多或少的有联系，例如整形的变长编码，他会把数据的二进制编码按7拆分，在每个字节的第一位使用1表示是否为数据的结尾，例如int(1)编码为&lt;code>00000001&lt;/code>，&lt;code>11 10101010&lt;/code>会编码为&lt;code>10101010 00000111&lt;/code>，对应压缩和解压代码如下，除了变长之外，还有定长编码，以及对应的32位，64位的实现等，在实际的数据处理中，会有记录数据长度等操作，就会使用编码操作，把数值编码到数据中。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c++" data-lang="c++">&lt;span class="kt">char&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="nf">EncodeVarint32&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">char&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">dst&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">uint32_t&lt;/span> &lt;span class="n">v&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="c1">// Operate on characters as unsigneds
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kt">uint8_t&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">ptr&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">reinterpret_cast&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">uint8_t&lt;/span>&lt;span class="o">*&amp;gt;&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">dst&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="k">static&lt;/span> &lt;span class="k">const&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">B&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">128&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">v&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="mi">7&lt;/span>&lt;span class="p">))&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="o">*&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">ptr&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">v&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">v&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="mi">14&lt;/span>&lt;span class="p">))&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="o">*&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">ptr&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">v&lt;/span> &lt;span class="o">|&lt;/span> &lt;span class="n">B&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="o">*&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">ptr&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">v&lt;/span> &lt;span class="o">&amp;gt;&amp;gt;&lt;/span> &lt;span class="mi">7&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">v&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="mi">21&lt;/span>&lt;span class="p">))&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="o">*&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">ptr&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">v&lt;/span> &lt;span class="o">|&lt;/span> &lt;span class="n">B&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="o">*&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">ptr&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">v&lt;/span> &lt;span class="o">&amp;gt;&amp;gt;&lt;/span> &lt;span class="mi">7&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">|&lt;/span> &lt;span class="n">B&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="o">*&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">ptr&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">v&lt;/span> &lt;span class="o">&amp;gt;&amp;gt;&lt;/span> &lt;span class="mi">14&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">v&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="mi">28&lt;/span>&lt;span class="p">))&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">const&lt;/span> &lt;span class="kt">char&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">GetVarint32PtrFallback&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">const&lt;/span> &lt;span class="kt">char&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">p&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">const&lt;/span> &lt;span class="kt">char&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">limit&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="kt">uint32_t&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">value&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="kt">uint32_t&lt;/span> &lt;span class="n">result&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">uint32_t&lt;/span> &lt;span class="n">shift&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">shift&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="mi">28&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">p&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">limit&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">shift&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="mi">7&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="kt">uint32_t&lt;/span> &lt;span class="n">byte&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">reinterpret_cast&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="k">const&lt;/span> &lt;span class="kt">uint8_t&lt;/span>&lt;span class="o">*&amp;gt;&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="p">));&lt;/span>
&lt;span class="n">p&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">byte&lt;/span> &lt;span class="o">&amp;amp;&lt;/span> &lt;span class="mi">128&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="c1">// More bytes are present
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">result&lt;/span> &lt;span class="o">|=&lt;/span> &lt;span class="p">((&lt;/span>&lt;span class="n">byte&lt;/span> &lt;span class="o">&amp;amp;&lt;/span> &lt;span class="mi">127&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="n">shift&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="n">result&lt;/span> &lt;span class="o">|=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">byte&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="n">shift&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="o">*&lt;/span>&lt;span class="n">value&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">result&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="k">reinterpret_cast&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="k">const&lt;/span> &lt;span class="kt">char&lt;/span>&lt;span class="o">*&amp;gt;&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="k">nullptr&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="arean">arean&lt;/h3>
&lt;p>自定义内存池，设计思路是申请内存和分配内存隔离，申请内存的时候多申请，分配内存的时候从已申请的内存中分配&lt;/p>
&lt;ul>
&lt;li>对于大空间，则直接申请，独占一个block，不受block大小的限制，且不改变之前记录的block的使用状态的记录&lt;/li>
&lt;li>对于小空间
&lt;ul>
&lt;li>第一次会申请大小为4k的空间，然后记录当前空间的指针及空间使用情况，然后分配空间&lt;/li>
&lt;li>之后的如果满足要求，则从之前申请的空间中分配&lt;/li>
&lt;li>如果不满足，则重新分配，之前残留的空间直接丢弃，且不计入使用空间统计&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c++" data-lang="c++">&lt;span class="kt">char&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">pool&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">area&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">Allocate&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">size&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// 不对齐的申请
&lt;/span>&lt;span class="c1">// char * pool = area-&amp;gt;AllocateAligned(size); // 申请对齐的空间
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">auto&lt;/span> &lt;span class="n">mem&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">pool&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="kt">char&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">size&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">Allocate&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">size&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">size&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">alloc_bytes_remaining_&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="kt">char&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">result&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">alloc_ptr_&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">alloc_ptr_&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="n">bytes&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">alloc_bytes_remaining_&lt;/span> &lt;span class="o">-=&lt;/span> &lt;span class="n">bytes&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">result&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nf">AllocateFallback&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">size&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="skiplist">skiplist&lt;/h3>
&lt;blockquote>
&lt;p>&lt;a href="https://www.jianshu.com/p/9d8296562806">https://www.jianshu.com/p/9d8296562806&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>跳表使用使用概率均衡的技术，是的大部分操作都可以实现&lt;code>O(log n)&lt;/code>的时间复杂度，可以参考上面的文章，这里总结几个点&lt;/p>
&lt;ol>
&lt;li>跳表可以简单的理解为链表的+index的实现，index的目的是为了快速的查找数据&lt;/li>
&lt;li>跳表在增加节点的时候，使用概率为0.25来确定使得否增加下一层，在这个概率下，空间需要花费的代价为&lt;code>(cost(node) * 1.33)&lt;/code>&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c++" data-lang="c++"> &lt;span class="k">static&lt;/span> &lt;span class="k">const&lt;/span> &lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">kBranching&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">height&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">height&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">kMaxHeight&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">rnd_&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">OneIn&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">kBranching&lt;/span>&lt;span class="p">))&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="n">height&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ol start="3">
&lt;li>查找的时间复杂度可以抽象的理解为二分查找的&lt;code>O(log n)&lt;/code>&lt;/li>
&lt;li>跳表的操作的时间复杂度和红黑树几乎差不多，但是有一点功能是红黑树无法实现的，即range search，红黑树由于结构特性，无法进行类似的操作，就像B-tree和B+tree，因为B+tree在叶子节点上可以实现range查询&lt;/li>
&lt;li>跳表结构简单，易于理解，易于实现，&lt;/li>
&lt;li>insert的时候先查找位置，然后按概率计算层高，再进行插入&lt;/li>
&lt;li>并发&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c++" data-lang="c++">&lt;span class="n">find&lt;/span> &lt;span class="n">pre&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">RandomHeight&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">fix&lt;/span> &lt;span class="n">pre&lt;/span> &lt;span class="n">on&lt;/span> &lt;span class="n">random&lt;/span> &lt;span class="n">height&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">new&lt;/span> &lt;span class="nf">node&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">height&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">set&lt;/span> &lt;span class="n">pointer&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ol start="7">
&lt;li>leveldb中，skiplist没有delete操作，如果需要实现，则需要实现类似insert中的部分操作，查找到pre，在设置节点即可。&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c++" data-lang="c++">&lt;span class="n">find&lt;/span> &lt;span class="n">pre&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">set&lt;/span> &lt;span class="n">pointer&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">delete&lt;/span> &lt;span class="n">node&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="writebatch">WriteBatch&lt;/h3>
&lt;p>写操作的主要操作对象，主要步骤是把操作的数据打包为一个buffer，然后使用&lt;code>WriteBatch::Iterate&lt;/code>操作handler实现insert操作，hanle是一个实现put和delete的接口，所以这里是把数据和操作分离了，这里有几点细节&lt;/p>
&lt;ol>
&lt;li>WriteBatch的数据格式为 &lt;code>seq|countkey|{type|key|val}&lt;/code>，batch添加一个数据的时候，除了正常添加数据，还会count加一，用于在&lt;code>WriteBatch::Iterate&lt;/code>的时候检测数据数量是否正确&lt;/li>
&lt;li>一个batch的数据只有一个sequence，batch写完之后，数值加一，&lt;/li>
&lt;li>有標記控制是否使用使用同步寫。默認為同步寫，異步寫入的速度快，但是可能導致系統崩潰的時候丟數據，所以爲了分攤大量數據的同步寫的cost，這裏設計WriteBatch來打包數據，進行一次同步寫操作，因爲是順序寫入磁盤，所以寫入速度可以接受&lt;/li>
&lt;li>写入操作具有原子性，在写数据的时候会先写日志然后再写数据，当写日志之前或者写日志过程中宕机，下次重启时恢复数据库的时候直接丢弃异常日志。或者写完日志之后宕机，系统在下次启动之后都是确保数据的原子性，&lt;/li>
&lt;/ol>
&lt;h3 id="posixenv">PosixEnv&lt;/h3>
&lt;p>posix环境资源的实现，继承自env，目的是便于实现不同平台下的代码，&lt;/p>
&lt;ul>
&lt;li>线程池，一个简单的例子 &lt;a href="https://github.com/progschj/ThreadPool">https://github.com/progschj/ThreadPool&lt;/a>&lt;/li>
&lt;li>日志&lt;/li>
&lt;li>文件&lt;/li>
&lt;/ul>
&lt;h3 id="wal">wal&lt;/h3>
&lt;blockquote>
&lt;p>&lt;a href="https://leveldb-handbook.readthedocs.io/zh/latest/journal.html">https://leveldb-handbook.readthedocs.io/zh/latest/journal.html&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>日志在写数据之前记录，写完之后立刻flush，之后才是真正的写数据到memtable，日志文件会一直保存，直到数据落盘才删除，即memtable变为immemtable且compact(数据落盘)之后才删除，如果期间系统异常，则日志文件保存，到下次重启之后回复之后才删除，&lt;/p>
&lt;hr>
&lt;p>(log::Writer)
写数据之前需要预写日志，目的是为了保证数据安全，在操作数据异常的时候可以使用日志恢复数据，按block划分，一个block大小为32k，一个block有四种状态&lt;/p>
&lt;ol>
&lt;li>kFullType&lt;br>
一个block可以存完数据&lt;/li>
&lt;li>kFirstType&lt;br>
一个block存不下数据，标记为第一个block&lt;/li>
&lt;li>kLastType&lt;br>
最后一个block&lt;/li>
&lt;li>kMiddleType&lt;br>
中间的block&lt;/li>
&lt;/ol>
&lt;p>每一个block中的数据的组织格式为&lt;code>crc|len(2)|type(1)|values&lt;/code>，其中values的数据来自于前面的WriteBatch打包的数据，是一个整体，没有做太多的处理，主要的调用方法为&lt;/p>
&lt;ul>
&lt;li>DBImpl::Write&lt;/li>
&lt;li>DBImpl::NewDB&lt;/li>
&lt;li>VersionSet::LogAndApply&lt;/li>
&lt;li>VersionSet::WriteSnapshot&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>(log::Reader)
wal对应的读取操作&lt;/p>
&lt;h3 id="cache">Cache&lt;/h3>
&lt;p>缓存，抽象类，有&lt;code>ShardedLRUCache&lt;/code>一个实现，内部自行额外的设计了几个特殊的结构，测试文件为&lt;code>cache_test.cc&lt;/code>。&lt;/p>
&lt;blockquote>
&lt;p>&lt;a href="https://leveldb-handbook.readthedocs.io/zh/latest/cache.html">https://leveldb-handbook.readthedocs.io/zh/latest/cache.html&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;h4 id="lrucache">LRUCache&lt;/h4>
&lt;ul>
&lt;li>ShardedLRUCache&lt;br>
LRUHandle的包装，主要原因是LRUHandle的接口都加锁，所以这里使用ShardedLRUCache包装一下，使用16个LRUHandle来管理缓存，以提高并发时候的操作效率。&lt;code>uint32_t Shard(uint32_t hash) { return hash &amp;gt;&amp;gt; (32 - kNumShardBits); }&lt;/code>会使用前4个bit计算位置，得到对应的LRUHandle对象，之后的操作使用此对象处理，相当于LRUHandle的hash表。&lt;/li>
&lt;li>LRUCache
&lt;blockquote>
&lt;p>&lt;a href="https://leetcode.cn/problems/lru-cache/">https://leetcode.cn/problems/lru-cache/&lt;/a>
LRU的实现，使用HandleTable作为hash表保存的数据。LRUHandle为链表保存数据，主要细节为&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>使用hash表保存数据&lt;/li>
&lt;li>使用一个LRUHandle维护使用情况，数据在缓存中的时候，要么只是在缓存中，保存在lru_链表中，或者是使用中的数据，保存在in_use_中&lt;/li>
&lt;li>使用引用标记数据的使用，只有当引用为0的时候，才会删除数据，当数据存在在缓存中的时候，引用默认为1，为0则表示不缓存且没有外部引用&lt;/li>
&lt;li>对于重复的key，会直接替换&lt;/li>
&lt;li>容量不足的时候。替换lru_中的数据，使用中的数据不操作&lt;/li>
&lt;li>链表在append的时候，使用是添加在链表头节点&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>LRUHandle&lt;br>
双向链表，在hash表中会保存数据，在LRU中会维护使用情况，
&lt;ul>
&lt;li>remove&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c++" data-lang="c++">&lt;span class="kt">void&lt;/span> &lt;span class="n">LRUCache&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">LRU_Remove&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">LRUHandle&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">e&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="n">e&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">next&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">prev&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">e&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">prev&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">e&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">prev&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">next&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">e&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">next&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>LRU_Append&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c++" data-lang="c++">&lt;span class="kt">void&lt;/span> &lt;span class="n">LRUCache&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">LRU_Append&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">LRUHandle&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">list&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">LRUHandle&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">e&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="c1">// Make &amp;#34;e&amp;#34; newest entry by inserting just before *list
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">e&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">next&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">list&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">e&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">prev&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">list&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">prev&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">e&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">prev&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">next&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">e&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">e&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">next&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">prev&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">e&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>HandleTable
LRUHandle的二维数组，使用连地址法来处理冲突&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>缓存有两种，一种是用来缓存的打开的SST table的cache，一种是用来缓存使用的block的cache&lt;/p>
&lt;/blockquote>
&lt;h3 id="sst">SST&lt;/h3>
&lt;p>&lt;img src="https://poorguyorz.github.io/posts/readbooks/image.png" alt="格式圖">
具體格式如圖，文件最后是footer，保存mata和index的大小和偏移，&lt;/p>
&lt;ul>
&lt;li>
&lt;p>footer (&lt;code>Footer::EncodeTo&lt;/code>)&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c++" data-lang="c++"> &lt;span class="n">int64&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="mi">2&lt;/span> &lt;span class="o">|&lt;/span> &lt;span class="n">mata&lt;/span>
&lt;span class="n">int64&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="mi">2&lt;/span> &lt;span class="o">|&lt;/span> &lt;span class="n">index&lt;/span>
&lt;span class="n">padding&lt;/span>
&lt;span class="n">magicnum&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>BlockBuilder&lt;br>
磁盘读写按照一定大小读取比较有效率，leveldb按照4K大小组织文件，4K为一个block，block按照一个一个的条目编码数据，格式为&lt;code>slen|uslen|vlen|uskey|v&lt;/code>，s指的是share，如下的例子&lt;/p>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c++" data-lang="c++"> &lt;span class="p">{&lt;/span>
&lt;span class="n">string&lt;/span> &lt;span class="n">key1&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s">&amp;#34;abcd&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">v1&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s">&amp;#34;vv1vv&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">string&lt;/span> &lt;span class="n">key2&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s">&amp;#34;abce&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">v2&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s">&amp;#34;vv2vv&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">string&lt;/span> &lt;span class="n">key3&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s">&amp;#34;abxf&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">v3&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s">&amp;#34;vv3vv&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">encode&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="mi">0&lt;/span> &lt;span class="mi">4&lt;/span> &lt;span class="mi">5&lt;/span> &lt;span class="n">abcd&lt;/span> &lt;span class="n">vv1vv&lt;/span> &lt;span class="o">|&lt;/span> &lt;span class="mi">3&lt;/span> &lt;span class="mi">1&lt;/span> &lt;span class="mi">5&lt;/span> &lt;span class="n">e&lt;/span> &lt;span class="n">vv2vv&lt;/span> &lt;span class="o">|&lt;/span> &lt;span class="mi">2&lt;/span> &lt;span class="mi">2&lt;/span> &lt;span class="mi">5&lt;/span> &lt;span class="n">xf&lt;/span> &lt;span class="n">vv3vv&lt;/span>&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>第一个记录不编码，第二个和第一个对比，编码存取，key抽取相同的前缀，记录长度，之后的数据都按前一个数据编码，如果数据太多，可能后面的key和之前的key差距比较大，查找的时候只能全部解码然后寻找key，所以设计可以控制每隔固定数量的key存一个完整的key，称为重启点，按重启点划分为不同的group，此时且记录key的偏移，此时查找的时候可以按照偏移取key然后使用二分查找等方式快速查寻。在持久化的时候，block末尾记录group的大小，再使用一个bit记录压缩格式，再使用4个bit记录crc。这就是block的基本格式
除了footer使用单独的编码格式之外。其余的mata，index，data都使用block的格式编码数据，&lt;/p>
&lt;ul>
&lt;li>写入流程&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c++" data-lang="c++">&lt;span class="n">TableBuilder&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">Add&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">r&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">pending_index_entry&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// 新的block设置index
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">index_block&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">Add&lt;/span>
&lt;span class="n">filter_block&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">AddKey&lt;/span> &lt;span class="c1">// 设置filter
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">data_block&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">Add&lt;/span> &lt;span class="c1">// 添加数据到data_block，如果大小达到限制，flush
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">estimated_block_size&lt;/span> &lt;span class="o">&amp;gt;=&lt;/span> &lt;span class="n">r&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">options&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">block_size&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="n">TableBuilder&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">Flush&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="n">TableBuilder&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">WriteBlock&lt;/span> &lt;span class="c1">// 写block
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">BlockBuilder&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">Finish&lt;/span> &lt;span class="c1">// 打包数据，编码group offset
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">compression&lt;/span> &lt;span class="c1">// 压缩
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">TableBuilder&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">WriteRawBlock&lt;/span> &lt;span class="c1">// 写压缩之后的数据，设置编码格式和crc
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">r&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">pending_index_entry&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">true&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 设置标记为true，记录index
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>
&lt;p>读取流程&lt;br>
讀取的時候逆向操作，校監crc&lt;/p>
&lt;/li>
&lt;li>
&lt;p>index
index的一個條目對應的是一個datablock中的最大的key以及block的偏移和大小，key使用FindShortestSeparator計算得出，確保他計算的key是當前保存的datablock中的最大值加1，目的是便於查找&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c++" data-lang="c++"> &lt;span class="nl">start&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">abcdef&lt;/span>
&lt;span class="nl">limit&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">abcdgh&lt;/span>
&lt;span class="n">FindShortestSeparator&lt;/span>&lt;span class="o">--&amp;gt;&lt;/span> &lt;span class="n">start&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">abcdf&lt;/span> &lt;span class="c1">// 公共前綴加1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;ul>
&lt;li>immemtable的寫入&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>&lt;a href="https://hardcore.feishu.cn/docs/doccn4w8clvork96K3dqQnJRh9g#">https://hardcore.feishu.cn/docs/doccn4w8clvork96K3dqQnJRh9g#&lt;/a>
&lt;a href="https://my.oschina.net/fileoptions/blog/903206">https://my.oschina.net/fileoptions/blog/903206&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c++" data-lang="c++">
&lt;span class="n">WriteLevel0Table&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="n">mutex_&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">Unlock&lt;/span>&lt;span class="p">();&lt;/span> &lt;span class="c1">// 不加鎖是因爲immemtable不可變，所以沒有并發問題
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">s&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">BuildTable&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">dbname_&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">env_&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">options_&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">table_cache_&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">iter&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">meta&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="nl">BuildTable&lt;/span> &lt;span class="p">:{&lt;/span>
&lt;span class="c1">// get file
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// add values
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">builder&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">Add&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">key&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">iter&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">value&lt;/span>&lt;span class="p">());&lt;/span>
&lt;span class="n">s&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">builder&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">Finish&lt;/span>&lt;span class="p">();&lt;/span>
&lt;span class="nl">Finish&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="c1">// filter
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// metaindex
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// index
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// footer
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="n">file&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">sync&lt;/span>&lt;span class="p">();&lt;/span>
&lt;span class="n">file&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">close&lt;/span>&lt;span class="p">();&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="n">mutex_&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">Lock&lt;/span>&lt;span class="p">();&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>具體的細節可以參考代碼的文檔，&lt;/p>
&lt;h3 id="迭代器">迭代器&lt;/h3>
&lt;p>訪問特定數據結構的抽象，使數據的訪問和存儲分離，可以參考STL的實現，levelDB中對不同的組件實現不同的迭代器&lt;/p>
&lt;ul>
&lt;li>MemTableIterator&lt;/li>
&lt;li>LevelFileNumIterator&lt;/li>
&lt;li>Block::Iter&lt;/li>
&lt;/ul>
&lt;h3 id="version">version&lt;/h3>
&lt;blockquote>
&lt;p>&lt;a href="https://leveldb-handbook.readthedocs.io/zh/latest/version.html">https://leveldb-handbook.readthedocs.io/zh/latest/version.html&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>本质上是使用版本号组成key，用来查询数据，之前数据存放的时候，是有记录seq的，version是专为这种行为设计的系统，&lt;/p>
&lt;h3 id="compact">compact&lt;/h3>
&lt;p>定期的数据的整理合并操作&lt;/p>
&lt;hr>
&lt;ul>
&lt;li>minor compaction&lt;br>
immemtable持久化为SST，可以手动使用TEST_CompactMemTable触发，主要方式是设置&lt;code>DBImpl::Write&lt;/code>的WriteBatch参数为null，此时在&lt;code>MakeRoomForWrite&lt;/code>中，会根据参数导致选择compact的分支，会进行CompactMemTable操作，此时之前的数据会固化到文件中。也可以自动触发，当memtable 满了之后，会进行相同的操作。
&lt;ul>
&lt;li>TIPS: 此时version中会保存SST的相关信息，包括beginkey和endkey，以及版本信息&lt;/li>
&lt;li>文件不一定是level0，对于大文件，预测level0可能很快到达限制，可以在一定条件下直接把文件放在较高层。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;ul>
&lt;li>Major Compaction&lt;br>
sst之间向下合并，其会把相同key的不同版本的数据合并，可以手动使用TEST_CompactRange触发，此时可以选择需要compact的level和start key和endkey，他会把文件向下层合并，这里需要注意的是
&lt;ul>
&lt;li>level0会有重叠的key，compact的时候需要选择beginkey endkey以及他中间覆盖的文件进行compact操作，否则会残留下old key，&lt;/li>
&lt;li>sst不一定是向下推一层，可以选择想要合并的层数，对于level 0，使用文件个数计算score，对于其他层，使用文件大小计算&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c++" data-lang="c++"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">level&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">level&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">config&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">kNumLevels&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">level&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="kt">double&lt;/span> &lt;span class="n">score&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">level&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="c1">// We treat level-0 specially by bounding the number of files
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// instead of number of bytes for two reasons:
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">//
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// (1) With larger write-buffer sizes, it is nice not to do too
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// many level-0 compactions.
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">//
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// (2) The files in level-0 are merged on every read and
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// therefore we wish to avoid too many files when the individual
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// file size is small (perhaps because of a small write-buffer
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// setting, or very high compression ratios, or lots of
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// overwrites/deletions).
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">score&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">v&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">files_&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">level&lt;/span>&lt;span class="p">].&lt;/span>&lt;span class="n">size&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="o">/&lt;/span>
&lt;span class="k">static_cast&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">double&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">config&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">kL0_CompactionTrigger&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="c1">// Compute the ratio of current size to size limit.
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">const&lt;/span> &lt;span class="kt">uint64_t&lt;/span> &lt;span class="n">level_bytes&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">TotalFileSize&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">v&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">files_&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">level&lt;/span>&lt;span class="p">]);&lt;/span>
&lt;span class="n">score&lt;/span> &lt;span class="o">=&lt;/span>
&lt;span class="k">static_cast&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">double&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">level_bytes&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="n">MaxBytesForLevel&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">options_&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">level&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">score&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">best_score&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="n">best_level&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">level&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">best_score&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">score&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>sst记录一个查询次数，当一个文件被查询多次且是无效查询的时候的，当达到一定次数就会触发compcat操作，理由是他可能和其他文件有太多的重复的key，需要被清理以平衡io操作，这里的依据是的一次额外的compact操作的cost和多次的无效seek的均衡。&lt;/li>
&lt;li>他的大致逻辑是当前使用的线程设置manual_compaction_信息，然后调用compact线程使用manual_compaction_执行compact操作&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;span class="lnt">36
&lt;/span>&lt;span class="lnt">37
&lt;/span>&lt;span class="lnt">38
&lt;/span>&lt;span class="lnt">39
&lt;/span>&lt;span class="lnt">40
&lt;/span>&lt;span class="lnt">41
&lt;/span>&lt;span class="lnt">42
&lt;/span>&lt;span class="lnt">43
&lt;/span>&lt;span class="lnt">44
&lt;/span>&lt;span class="lnt">45
&lt;/span>&lt;span class="lnt">46
&lt;/span>&lt;span class="lnt">47
&lt;/span>&lt;span class="lnt">48
&lt;/span>&lt;span class="lnt">49
&lt;/span>&lt;span class="lnt">50
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c++" data-lang="c++">&lt;span class="n">compact&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="n">BackgroundCompaction&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">imm_&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="k">nullptr&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="n">CompactMemTable&lt;/span>&lt;span class="p">();&lt;/span>
&lt;span class="k">return&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="n">Compaction&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">c&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">is_manual&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="c1">// 执行manual compact，优先级最高，获得Compaction
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">c&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">versions_&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">CompactRange&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">m&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">level&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">m&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">begin&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">m&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">end&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">c&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="k">nullptr&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="c1">// 不做处理，不需要compact
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span>&lt;span class="k">else&lt;/span> &lt;span class="nf">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">is_manual&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">c&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">IsTrivialMove&lt;/span>&lt;span class="p">())&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="c1">// 仅仅只需要移动文件，例如最开始的时候下层没有需要合并的文件，直接移动文件，修改元数据即可
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="c1">// 执行compact
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">CompactionState&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">compact&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">CompactionState&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">c&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">status&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">DoCompactionWork&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">compact&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="c1">// 多个文件的合并操作，会处理过期或者需要删除的数据
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">DoCompactionWork&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="n">Iterator&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">input&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">versions_&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">MakeInputIterator&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">compact&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">compaction&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">input&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">Valid&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="o">!&lt;/span>&lt;span class="n">shutting_down_&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">load&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">memory_order_acquire&lt;/span>&lt;span class="p">))&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">has_imm_&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">load&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">memory_order_relaxed&lt;/span>&lt;span class="p">))&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="c1">// 如果有minor compact，则优先处理
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="c1">// 判断重叠，重叠太多影响查询，直接终止
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="n">compact&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">compaction&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">ShouldStopBefore&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">key&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">break&lt;/span>&lt;span class="err">；&lt;/span>
&lt;span class="c1">// 处理key
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="c1">// 如果是delete
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// 或者是sequence小于当前使用中的sequence
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// 或者更高层没有这个key
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">drop&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">true&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">drop&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="n">compact&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">builder&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">Add&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">key&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">input&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">value&lt;/span>&lt;span class="p">());&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ul>
&lt;p>由于compact的时候，会占用一定的系统资源，所以如果发生compaction的时候&lt;/p>
&lt;ul>
&lt;li>如果是minor compact，则减缓写操作，释放一定的系统资源&lt;/li>
&lt;li>如果是Major Compaction，则暂停操作。等待compact任务完成&lt;/li>
&lt;/ul></content><category scheme="https://poorguyorz.github.io/posts/" term="posts" label="posts"/><category scheme="https://poorguyorz.github.io/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/" term="源码阅读" label="源码阅读"/><category scheme="https://poorguyorz.github.io/tags/leveldb/" term="LevelDB" label="LevelDB"/></entry><entry><title type="text">VolcanoOptimizer</title><link rel="alternate" type="text/html" href="https://poorguyorz.github.io/posts/readbooks/volcanooptimizer/"/><id>https://poorguyorz.github.io/posts/readbooks/volcanooptimizer/</id><updated>2022-05-15T22:37:28+08:00</updated><published>2022-04-04T22:10:50+08:00</published><author><name>poor Guy</name><uri>https://poorguyorz.github.io/</uri><email>a_designer@qq.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">NOTE 论文阅读笔记The Volcano Optimizer Generator: Extensibility and Efficient Search 可扩展 面向对象 自顶向下 剪枝 原型是EXODUS， Vo……</summary><content type="html">&lt;h1 id="note">NOTE&lt;/h1>
&lt;p>论文阅读笔记&lt;a href="http://www.cse.iitb.ac.in/infolab/Data/Courses/CS632/Papers/Volcano-graefe.pdf">The Volcano Optimizer Generator: Extensibility and Efficient Search&lt;/a>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>可扩展&lt;/p>
&lt;/li>
&lt;li>
&lt;p>面向对象&lt;/p>
&lt;/li>
&lt;li>
&lt;p>自顶向下&lt;/p>
&lt;/li>
&lt;li>
&lt;p>剪枝&lt;/p>
&lt;/li>
&lt;li>
&lt;p>原型是EXODUS， Volcano是对他的改进&lt;/p>
&lt;ul>
&lt;li>可以单独使用的优化器&lt;/li>
&lt;li>优化搜索时间和搜索空间&lt;/li>
&lt;li>可扩展&lt;/li>
&lt;li>可以使用启发式算法和有效的代价模型来扩展和减少搜索空间，【剪枝】&lt;/li>
&lt;li>灵活的成本计算模型&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>一个框架，优化器生成器，可以由“optimizer implementor”自行实现关键函数，整个优化器框架的输入是AST，输出是一个执行计划，算子的集合&lt;/p>
&lt;/li>
&lt;li>
&lt;p>SQL是基于关系代数，Volcano把关系表达式分为逻辑表达式和物理表达式，逻辑表达式之间使用transformation进行转换，物理表达式使用基于代价的implementation和逻辑表达式映射的，关系不一定是意义对应的，例如scan可以同时一起实现projection&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在表达式进行转换的时候可以使用condition进行模式判断，满足条件的时候可以进行变换&lt;/p>
&lt;/li>
&lt;li>
&lt;p>表达式使用特征描述输出，&lt;/p>
&lt;/li>
&lt;li>
&lt;p>enforcers会强制添加某属性，用于指导优化器进行优化，例如指定表的scan方式&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>Logical Operator&lt;br>
Operator set，也就是可以描述在目标data model上可以执行的代数运算合&lt;br>
Transformation rules + Condition，对每条等价变换规则，在满足condition时才可以应用&lt;br>
Logical properties : 逻辑属性，用来描述代数运算的输出所具有的一些特征，这些特征与运算的具体执行方式无关，是逻辑的，例如输出的行数，结果集的schema等&lt;/p>
&lt;p>Physical Operator&lt;br>
Algorithm + Enforcer set，即可应用的物理实现算法 + 可添加的Enforcer集合&lt;br>
Implementation rules + Condition，满足Condition的前提下，可以尝试该物理算法&lt;br>
Cost model + Cost formula，基于cost选择最优的物理算法&lt;br>
Physical property，与logical property对应，物理属性是选择了特定的算法实现后，输出的数据所具有的物理上的特性，例如数据是否有序、是否具有唯一性，数据在多机上的分布情况等，不同的物理算法，会决定执行该operator产生的物理属性，例如sort merge join会在join key上产生有序属性&lt;br>
Applicability function : 决定一个物理算法，其输出是否可以满足要求父算子对自身的physical property要求，且决定它对自身的输入具有什么样的physical property要求&lt;br>
Enforcer是search engine中一个重要的概念，它用来强制产生某种物理属性。例如上层是join算子，在枚举时会考虑使用sort merge join的物理执行方式(Implementation），但当递归到下层时，子节点可以选择table scan（无序输出），或者index scan（目标序输出），当选择table scan时，由于输出不满足父算子对自身输出的物理属性要求，就可以通过Order Enforcer来产生目标输出，Enforcer表示了排序这个操作，同时也包含了排序操作会产生的代价。&lt;/p>
&lt;h2 id="the--search--engine">The Search Engine&lt;/h2>
&lt;p>搜索实现&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;span class="lnt">36
&lt;/span>&lt;span class="lnt">37
&lt;/span>&lt;span class="lnt">38
&lt;/span>&lt;span class="lnt">39
&lt;/span>&lt;span class="lnt">40
&lt;/span>&lt;span class="lnt">41
&lt;/span>&lt;span class="lnt">42
&lt;/span>&lt;span class="lnt">43
&lt;/span>&lt;span class="lnt">44
&lt;/span>&lt;span class="lnt">45
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c++" data-lang="c++">&lt;span class="c1">// PhysProp：： 此LogExpr锁具有的物理属性的要求
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="n">FindBestPlan&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">LogExpr&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">PhysProp&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">Limit&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="c1">// 如果可以在look-up table找到满足的计划，则代表以及算过，直接返回
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="n">the&lt;/span> &lt;span class="n">pair&lt;/span> &lt;span class="n">LogExpr&lt;/span> &lt;span class="n">and&lt;/span> &lt;span class="n">PhysProp&lt;/span> &lt;span class="n">is&lt;/span> &lt;span class="n">in&lt;/span> &lt;span class="n">the&lt;/span> &lt;span class="n">look&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">up&lt;/span> &lt;span class="n">table&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="n">the&lt;/span> &lt;span class="n">cost&lt;/span> &lt;span class="n">in&lt;/span> &lt;span class="n">the&lt;/span> &lt;span class="n">look&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">up&lt;/span> &lt;span class="n">table&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">Limit&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">Plan&lt;/span> &lt;span class="n">and&lt;/span> &lt;span class="n">Cost&lt;/span>
&lt;span class="k">else&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">failure&lt;/span>
&lt;span class="cm">/* else: optimization required */&lt;/span>
&lt;span class="c1">// 否则进行优化，由三种优化方式
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// 1. 使用转换方法转换为等价的逻辑表达式，且使用相同物理属性计算
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// 2. 使用实现方法生成物理表达式，此处是本层的物理表达式，所以会递归调用，且计算本层代价TotalCost，此时是使用
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// 代价模型计算代价且使用剪枝
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// Applicability functio决定Implementation是否满足PhysProp
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// 3. 使用enforcer，计算enforcer的代价，且修改PhysProp为满足enforcer的PhysProp，使用新的PhysProp计算LogExpr
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">create&lt;/span> &lt;span class="n">the&lt;/span> &lt;span class="n">set&lt;/span> &lt;span class="n">of&lt;/span> &lt;span class="n">possible&lt;/span> &lt;span class="s">&amp;#34;moves&amp;#34;&lt;/span> &lt;span class="n">from&lt;/span>
&lt;span class="o">-&lt;/span> &lt;span class="n">applicable&lt;/span> &lt;span class="n">transformations&lt;/span>
&lt;span class="o">-&lt;/span> &lt;span class="n">algorithms&lt;/span> &lt;span class="n">that&lt;/span> &lt;span class="n">give&lt;/span> &lt;span class="n">the&lt;/span> &lt;span class="n">required&lt;/span> &lt;span class="n">PhysProp&lt;/span>
&lt;span class="o">-&lt;/span> &lt;span class="n">enforcers&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="n">required&lt;/span> &lt;span class="n">PhysProp&lt;/span>
&lt;span class="n">order&lt;/span> &lt;span class="n">the&lt;/span> &lt;span class="n">set&lt;/span> &lt;span class="n">of&lt;/span> &lt;span class="n">moves&lt;/span> &lt;span class="n">by&lt;/span> &lt;span class="n">promise&lt;/span>
&lt;span class="k">for&lt;/span> &lt;span class="n">the&lt;/span> &lt;span class="n">most&lt;/span> &lt;span class="n">promising&lt;/span> &lt;span class="n">moves&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="n">the&lt;/span> &lt;span class="n">move&lt;/span> &lt;span class="n">uses&lt;/span> &lt;span class="n">a&lt;/span> &lt;span class="n">transformation&lt;/span>
&lt;span class="n">apply&lt;/span> &lt;span class="n">the&lt;/span> &lt;span class="n">transformation&lt;/span> &lt;span class="n">creating&lt;/span> &lt;span class="n">NewLogExpr&lt;/span>
&lt;span class="n">call&lt;/span> &lt;span class="n">FindBestPlan&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">NewLogExpr&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">PhysProp&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">Limit&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">else&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="n">the&lt;/span> &lt;span class="n">move&lt;/span> &lt;span class="n">uses&lt;/span> &lt;span class="n">an&lt;/span> &lt;span class="n">algorithm&lt;/span>
&lt;span class="nl">TotalCost&lt;/span> &lt;span class="p">:&lt;/span>&lt;span class="o">=&lt;/span> &lt;span class="n">cost&lt;/span> &lt;span class="n">of&lt;/span> &lt;span class="n">the&lt;/span> &lt;span class="n">algorithm&lt;/span>
&lt;span class="k">for&lt;/span> &lt;span class="n">each&lt;/span> &lt;span class="n">input&lt;/span> &lt;span class="n">I&lt;/span> &lt;span class="k">while&lt;/span> &lt;span class="n">TotalCost&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">Limit&lt;/span>
&lt;span class="n">determine&lt;/span> &lt;span class="n">required&lt;/span> &lt;span class="n">physical&lt;/span> &lt;span class="n">properties&lt;/span> &lt;span class="n">PP&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="n">I&lt;/span>
&lt;span class="n">Cost&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">FindBestPlan&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">I&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">PP&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">Limit&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">TotalCost&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="n">add&lt;/span> &lt;span class="n">Cost&lt;/span> &lt;span class="n">to&lt;/span> &lt;span class="n">TotalCost&lt;/span>
&lt;span class="k">else&lt;/span>&lt;span class="cm">/* move uses an enforcer */&lt;/span>
&lt;span class="nl">TotalCost&lt;/span> &lt;span class="p">:&lt;/span>&lt;span class="o">=&lt;/span> &lt;span class="n">cost&lt;/span> &lt;span class="n">of&lt;/span> &lt;span class="n">the&lt;/span> &lt;span class="n">enforcer&lt;/span>
&lt;span class="n">modify&lt;/span> &lt;span class="n">PhysProp&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="n">enforced&lt;/span> &lt;span class="n">property&lt;/span>
&lt;span class="n">call&lt;/span> &lt;span class="n">FindBestPlan&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="n">LogExpr&lt;/span> &lt;span class="n">with&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">PhysProp&lt;/span>
&lt;span class="cm">/* maintain the look-up table of explored facts */&lt;/span>
&lt;span class="c1">// 如果没有在look-up table找到满足的计划，则insert
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="n">LogExpr&lt;/span> &lt;span class="n">is&lt;/span> &lt;span class="n">not&lt;/span> &lt;span class="n">in&lt;/span> &lt;span class="n">the&lt;/span> &lt;span class="n">look&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">up&lt;/span> &lt;span class="n">table&lt;/span>
&lt;span class="n">insert&lt;/span> &lt;span class="n">LogExpr&lt;/span> &lt;span class="n">into&lt;/span> &lt;span class="n">the&lt;/span> &lt;span class="n">look&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">up&lt;/span> &lt;span class="n">table&lt;/span>
&lt;span class="c1">// 记录左右执行计划
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">insert&lt;/span> &lt;span class="n">PhysProp&lt;/span> &lt;span class="n">and&lt;/span> &lt;span class="n">best&lt;/span> &lt;span class="n">plan&lt;/span> &lt;span class="n">found&lt;/span> &lt;span class="n">into&lt;/span> &lt;span class="n">look&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">up&lt;/span> &lt;span class="n">table&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">best&lt;/span> &lt;span class="n">Plan&lt;/span> &lt;span class="n">and&lt;/span> &lt;span class="n">Cost&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>自定向下的搜索，使用三种规则向下扩展搜索空间，使用look-up table记录已搜索的表达式，在表达式没有新的扩展方法，或者达到代价阈值的时候停止搜索，&lt;/p>
&lt;h2 id="自顶向下和自底向上">自顶向下和自底向上&lt;/h2>
&lt;ul>
&lt;li>自顶向下
volcano，cascades等
&lt;ol>
&lt;li>在等价变形的范围不仅仅限于join，关系代数的等价变换都可以实现，所以理论上，这里可以使用一些启发式的算法，而不必要进行分层&lt;/li>
&lt;li>可以在优化的过程中基于代价模型进行剪枝&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>自底向上
几乎会枚举所有的执行计划，由更大的搜索空间，且由于在优化的过程中更多的只是为了搜索join order 的执行计划，所以需要提前进行一些启发式的算法，或优化语句结构便于优化器优化，或提前搜索到执行计划结束优化过程。&lt;/li>
&lt;/ul>
&lt;h1 id="the-cascades-framework-for-query-optimization">[The Cascades Framework for Query Optimization]&lt;/h1>
&lt;p>对于volcano的改进和优化&lt;/p>
&lt;ul>
&lt;li>把原来的搜索流程拆分为单个的task，使用栈来实现，task之间使用一个DGA来维护调度关系&lt;/li>
&lt;li>不区分逻辑表达式和物理表达式是&lt;/li>
&lt;li>rule抽象为task，是具体的对象，apply 的时候区分表达类型&lt;/li>
&lt;/ul>
&lt;p>group：
等价表达式的集合
expr：
表达式，等价表达式使用特征输入和特征输出来表示，表达式的输入可以是表达式，也可以是group，可以视为执行计划中的一个片段。
rule
抽象实现，分为逻辑表达式的转换rule和逻辑表达式转换到物理表达式的Implementation rule
是否可以适用某个rule需要判断表达式可以满足rule的某些要求的规则，这个规则抽象为pattern，如果满足pattern，则可以使用此转换方法转换表达式，转换之后的表达式称为Substitution&lt;/p>
&lt;ul>
&lt;li>OptimizeGroupTask
优化任务的入口，初始化的时候是整个ast的集合&lt;/li>
&lt;li>OptimizeExprTask
对于group中的所有的表达式，一个表达式可能只是单纯的表达式，也有可能是由其他group作为输入的表达式，所以
&lt;ol>
&lt;li>都表达式使用ApplyRuleTask入栈&lt;/li>
&lt;li>对于所有表达式中的group，使用ExploreGroupTask入栈，此时对于此节点，会先完成ExploreGroupTask，然后再使用ApplyRuleTask&lt;/li>
&lt;li>如果是物理表达式，则使用CreatePlanTask&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>ApplyRuleTask
对表达式使用rule转换，使用nextSubstitute之后得到Substitution，可以对新的表达式使用
&lt;ol>
&lt;li>ExploreExprTask&lt;/li>
&lt;li>OptimizeExprTask&lt;/li>
&lt;li>CreatePlanTask 如果是逻辑表达式，则使用CreatePlanTask&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>ExploreGroupTask
对group中的所有表达式调用ExploreExprTask&lt;/li>
&lt;li>ExploreExprTask
对所有的表达式，调用ApplyRuleTask，在表达式使用ApplyRuleTask之前，会先使用ExploreGroupTask扩展表达式的group&lt;/li>
&lt;li>CreatePlanTask
对应的是implementation rule，转换表达式为物理表达式&lt;/li>
&lt;/ul>
&lt;p>其中ApplyRuleTask某个表达式的时候，会先递归的使用ExploreGroupTask处理表达式的所有group，所以在transformation某个规则的时候，是整体的引用到整个表达式上&lt;/p></content><category scheme="https://poorguyorz.github.io/posts/" term="posts" label="posts"/></entry><entry><title type="text">Columbia Optimizer</title><link rel="alternate" type="text/html" href="https://poorguyorz.github.io/posts/readbooks/columbia-optimizer/"/><id>https://poorguyorz.github.io/posts/readbooks/columbia-optimizer/</id><updated>2022-05-15T22:37:28+08:00</updated><published>2022-04-02T16:55:12+08:00</published><author><name>poor Guy</name><uri>https://poorguyorz.github.io/</uri><email>a_designer@qq.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">start EFFICIENCY IN THE COLUMBIA DATABASE QUERY OPTIMIZER 优化器发展版本 第一代 模块化的，分层的，可扩展的，基于规则的优化器 扩展……</summary><content type="html">&lt;h1 id="start">start&lt;/h1>
&lt;p>EFFICIENCY IN THE COLUMBIA DATABASE QUERY OPTIMIZER&lt;/p>
&lt;h2 id="优化器发展版本">优化器发展版本&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>第一代&lt;/p>
&lt;ul>
&lt;li>模块化的，分层的，可扩展的，基于规则的优化器&lt;/li>
&lt;li>扩展的复杂性，搜索性能&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>第二代&lt;/p>
&lt;ul>
&lt;li>类似Volcano，更加优秀的优化规则，且使用物理属性参与优化，使用新的搜索方式&lt;/li>
&lt;li>更加灵活，但是还是难与扩展&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>第三代&lt;/p>
&lt;ul>
&lt;li>使用面对象的思想实现的优化器，易于扩展，更灵活&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>可以按照搜索策略分为两类
1. 自底向上
2. 自顶向下
Cascades Optimizer Framework
对关键操作定义为抽象类，通过实现抽象类来添加规则或者进行表达式变换来扩展优化器，
* 使用hash来消除重复的表达式
* 再group中把逻辑表达式和物理表达式分开
* 剪枝
先计算上层group的cost 阈值，在计算下层节点的时候，直接判断是否还需要继续进行优化
预先对执行计划设置阈值，当执行计划的代价和阈值足够接近的时候，则判定已完成搜索&lt;/p>
&lt;h2 id="术语">术语&lt;/h2>
&lt;ul>
&lt;li>&lt;/li>
&lt;/ul></content><category scheme="https://poorguyorz.github.io/posts/" term="posts" label="posts"/></entry><entry><title type="text">面试</title><link rel="alternate" type="text/html" href="https://poorguyorz.github.io/posts/bigdata/log/"/><id>https://poorguyorz.github.io/posts/bigdata/log/</id><updated>2022-05-15T22:37:28+08:00</updated><published>2022-03-24T20:26:11+08:00</published><author><name>poor Guy</name><uri>https://poorguyorz.github.io/</uri><email>a_designer@qq.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">面试 只是一个技术汇总 C++基础 [2 days] [课程- https://github.com/parallel101/course.git] 内存 内存结构 [https://segmentfault.com/a/1190000039348996] c++ 编译出来的是可执行文件，……</summary><content type="html">&lt;h1 id="面试">面试&lt;/h1>
&lt;p>只是一个技术汇总&lt;/p>
&lt;hr>
&lt;ul>
&lt;li>
&lt;p>C++基础 [2 days] [课程- https://github.com/parallel101/course.git]&lt;/p>
&lt;ul>
&lt;li>内存
&lt;ul>
&lt;li>
&lt;p>内存结构 [https://segmentfault.com/a/1190000039348996]&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>c++ 编译出来的是可执行文件，是ELF格式的，他本来就有一些格式上的划分，C++在他的基础上进行了更细的划分，分为五个部分，从高地址到底地址依次为：&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>1. 内核虚拟内存&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>进程的虚拟印象&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>2. 栈&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>程序自动控制，具体为程序的函数调用，保存局部变量，有大小，可以使用ulimit -s 查看，也可以自行设置，但是建议系统默认即可&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>* 函数调用机制&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>调用的时候是一个一个的栈帧，函数参数会在调用者的栈帧中开辟空间，从右到左，所以函数列表的默认值必须从右到左的初始化， 可能和这个有关系，然后被调用者构造栈帧，依次执行&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;pre>&lt;code> 3. 共享库的内存印象
3. 堆
空间有程序员自行维护，向上增长(TIPS: 由于C的历史原因，C++的内存结构还是说堆区，但是在区别new/malloc 和delete/free 的时候，他们的差别之一可能会在内存上有点区别
C的malloc/free可能会说是在堆上分配空间，但是对于C++可能会说的是在自由存储区上分配，自由存储区和堆是不同的概念，堆是操作系统上的概念，但是自由存储区是一个抽象概念
一般new可以是在堆上分配空间，但是可能存在在其他情况，例如在栈上使用new，所以他们不是一个概念，面试的时候说到这里，可以装逼😎)
4. 可写/全局区
对应elf中data段和bss段，data段保存的是已初始化的全局变量或者静态变量，bss保存的是未初始化的数据
5. 只读区
text段，保存编译之后的指令，不可变
6. 常量区
保存全局变量，不可变，rodata段，记得使用其他手段去尝试修改常量的时候会报错。
TIPS: const修饰的参数不一定是常量，例如他修饰一个函数的参数的时候，参数还是只是在栈中，只是约定不能修改。
7. 未使用
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>内存管理&lt;/p>
&lt;ul>
&lt;li>new
C++有对象的概念，所以他的new大意上是malloc的封装，先申请对象的内存空间，然后调用对象的构造函数构造对象，用在数组上是，先申请所有的空间，然后再依次调用构造函数&lt;/li>
&lt;li>delete
删除对象，先调用析构函数，然后再释放空间
&lt;ul>
&lt;li>对象数组
如果调用的是delete[]，如果是基础类型，则删除的时候使用delete和delete[] 都没有区别，因为空间连续的，有额外的空间记录内存的大小，直接使用delete的时候可以直接伤处 如果是自定义对象，如果有指针这类的属性，则必须调用delete[]，
否则他只会调用第一个对象的析构函数，可能会导致内存泄露&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&amp;ndash; new malloc 的区别&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>1. 空间分配的概念上&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>一个是堆区，一个是自由存储区&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>2. 使用上&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>new会调用构造函数，且new会自行计算对象所需的空间大小，malloc需要自行指定&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>3. 概念上&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>malloc是标准函数，而new是关键字&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/li>
&lt;li>
&lt;p>虚表&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.zhihu.com/question/389546003/answer/1194780618">实现&lt;/a>&lt;br>
虚表是多态的一种实现，但是不是C++的规定，而是编译器的自行的实现方法，在函数中只要声明虚函数，则对象中就会有额外的空间用于保存虚表，他是一个指针，指向虚表，所以对于有虚表的对象
sizeof的时候会计算这个指针的大小，指针指向虚表的第三个槽位，gdb查看地址的时候会显示+16的字样，因为这是实际的函数指针的开始位置，前两个槽位一个一般是0，拎一个一般是typeinfo的地址，
虚表和他的附属信息在内存中都是一起的，其实从根本原理上来说，他只是做了一层转换，实际上函数的调用最终的实现都是面向过程的函数的调用，函数才是C++ 的核心，&lt;br>
而且虚表由于调用的时候需要寻址，所以会导致性能问题，主要是由于需要进行地址跳转，跳转会有性能损耗，且由于局部性原理，指令会有预读机制，跳转之后可能导致cache miss，导致流水线失效
&lt;ul>
&lt;li>验证方法&lt;br>
编译的时候使用参数-fdump-lang-class，gdb调试的时候使用set print asm-demangle on，然后x/b打印地址&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>虚继承
同样使用到虚表，父类只有一份副本&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>智能指针&lt;/p>
&lt;/li>
&lt;li>
&lt;p>STL&lt;br>
两级情况，如果对象小于128K，则使用内存池，如果大于128K，则向系统申请空间，内存池使用链表维护&lt;/p>
&lt;/li>
&lt;li>
&lt;p>构造函数&lt;/p>
&lt;ol>
&lt;li>构造函数 （&lt;code>A();&lt;/code>）&lt;/li>
&lt;li>拷贝构造函数（&lt;code>A(const A&amp;amp;);&lt;/code>）&lt;/li>
&lt;li>析构函数（&lt;code>~A();&lt;/code>）&lt;/li>
&lt;li>重载赋值运算函数（&lt;code>A&amp;amp; operator = (const A&amp;amp;);&lt;/code>）&lt;/li>
&lt;li>重载取址运算函数（&lt;code>A* operator &amp;amp; ();&lt;/code>）&lt;/li>
&lt;li>重载取址const运算函数（&lt;code>const A* operator &amp;amp; () const;&lt;/code>）&lt;/li>
&lt;li>移动构造函数（&lt;code>A(A&amp;amp;&amp;amp;);&lt;/code>）&lt;/li>
&lt;li>重载移动复制函数（&lt;code>A&amp;amp; operator = (const A&amp;amp;&amp;amp;);&lt;/code>）&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>模板
编译期按照实际的类型进行代码的动态扩展，遇到使用的新的模板类型的时候，就编译出对应的类型的代码。类似与在编译期对代码进行重载。&lt;/p>
&lt;ul>
&lt;li>模板参数除了类型，还支持整形，但是必须是常量&lt;/li>
&lt;li>模板使用的时候，会自动进行类型推导。无序声明参数&lt;/li>
&lt;li>模板是惰性编译的，只有使用到了才会编译。所以模板的实现最好写在一起&lt;/li>
&lt;li>lambda也支持模板&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>多线程内存模型&lt;/p>
&lt;ul>
&lt;li>线程
线程运行时有单独的运行栈，如果是局部变量，则无数竞争的情况，如果有数据竞争的情况，则需要了解
0. 缓存架构
多线程下数据竞争的问题几乎都是缓存导致，缓存当前普遍的模型是三层，L1L2单独对应cpu，L3对应一个核上的所有CPU，如果多线程的情况下，可能会有缓存不一致的情况，导致结果不符合预期，简单的例子是多线程的数据累加，解决方法是使用锁或者信号量或者把变量设置未原子类型。
&lt;ol>
&lt;li>指令重排
有几种情况，一是编译器优化，二是cpu优化，三是cpu的乱序执行，它可以在一个始终周期内执行多条指令，所以可能看起来是无序的&lt;/li>
&lt;li>内存顺序&lt;/li>
&lt;li>volatile
在使用某个变量的时候，会直接从变量地址取数据，但是不保证更改的时候的原子性，所以上面0中的场景不可以使用volatile解决。本意是禁止变量的优化&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>函数
C++支持自定义对象，可以使用自己定义的函数，最终的是实现是把函数编译成为普通函数，只是函数的参数列表默认的会带上一个对象的指针，最底层实际上还是类似于C的面向过程。&lt;/li>
&lt;li>语法&lt;/li>
&lt;li>编译&lt;/li>
&lt;li>STL
&lt;ul>
&lt;li>容器
简单的理解就是具体的数据结构的实现，然后提供了具体的实现方法，对于通用的函数，则单独使用算法实现，
&lt;ul>
&lt;li>容器分类
&lt;ul>
&lt;li>序列式
&lt;ul>
&lt;li>array
数组，空间上连续，预分配空间。不可自动扩容，简单的数组的封装&lt;/li>
&lt;li>vector
解决array的问题，自动扩容，扩容时需要重新分配空间，然后移动数据到新空间，这个操作可能会导致迭代器失效，扩容因子不确定，有的是1.5倍增长，有的是2，扩容有性能问题，所以使用的时候明确场景，然后预先设置容量，避免扩容操作&lt;/li>
&lt;li>deque
双向队列，是用多段数组和一个控制中心实现的&lt;/li>
&lt;li>stack/queue
对列和栈，使用deque实现&lt;/li>
&lt;li>list
双向链表&lt;/li>
&lt;li>单向链表&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>关联式
&lt;ul>
&lt;li>map
底层有一个隐藏的红黑树容器，存储键值对，按键排序&lt;/li>
&lt;li>set
同map，但是是键值和一的&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>迭代器
迭代器在删除数据的时候可能会导致失效问题，对于内存空间上连续的容器，由于删除之后需要其他的数据填补空洞，所以迭代器会移动到下一个位置，对于关联式容器，当前元素迭代器失效，需要手动记录下一个元素位置&lt;/li>
&lt;li>容器使用&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>算法
&lt;ul>
&lt;li>STL中的一大项，由于是为了配合容器使用，所以几乎所有的算法都需要使用迭代器作为参数，然后大部分算法可以自行提供计算规则&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>特性
&lt;ul>
&lt;li>11新特性&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>GDB
&lt;ul>
&lt;li>调试技巧&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>数据结构与算法 [3 天整理知识列表，长期进行]&lt;/p>
&lt;ul>
&lt;li>树
&lt;ul>
&lt;li>二叉树&lt;/li>
&lt;li>堆&lt;/li>
&lt;li>234树&lt;/li>
&lt;li>红黑树&lt;/li>
&lt;li>B树&lt;/li>
&lt;li>B+树&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>hash&lt;/li>
&lt;li>线性表
&lt;ul>
&lt;li>数组&lt;/li>
&lt;li>链表&lt;/li>
&lt;li>队列&lt;/li>
&lt;li>栈&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>图
&lt;ul>
&lt;li>存储方式&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>跳表&lt;/li>
&lt;li>LRU&lt;/li>
&lt;li>排序&lt;/li>
&lt;li>dfs&lt;/li>
&lt;li>bfs&lt;/li>
&lt;li>二分&lt;/li>
&lt;li>&amp;hellip;&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>数据库 [3 天整理知识列表]&lt;/p>
&lt;ul>
&lt;li>
&lt;p>编译&lt;/p>
&lt;ul>
&lt;li>
&lt;p>编译原理&lt;/p>
&lt;/li>
&lt;li>
&lt;p>SQL编译过程
词法分析 语法分析之后得到ast，然后使用元数据堆ast进行类型绑定，同时进行常规检查，类似语义分析
词法分析和语法分析的大致过程为先堆语句进行分词，生成token，常见的工具为yacc，然后使用语义分析工具接收tioken，进行语义检查且生成语法树，语法分析有几种分析方法，一是自底向上，二是自顶向下，&lt;/p>
&lt;ul>
&lt;li>文法
&lt;ul>
&lt;li>LL(k)文法，第一个L指的是left to right，第二个L指的是最左推导&lt;/li>
&lt;li>LR文法，R指的是最右推导，也成为最左规约&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>自顶向下
从token序列的最左端开始，读入token，然后匹配已有的规则，如果匹配到最后正在匹配的规则和输入不匹配，则进行回溯，匹配下一个可以匹配的规则，如果没有可以匹配的，则失败，特点是可能需要进行大量的回溯&lt;/li>
&lt;li>自底向上
从输入的token开始，依次入栈，称为移进操作，然后如果栈中的数据可以匹配某规则，则使用规则替换，称为规约，反复进行此动作，直到生成一个语法树，每一次规约都会产生一个节点，此方法使用比较广泛，因为没有回溯操作，&lt;/li>
&lt;/ul>
&lt;p>tip： SQL说到底也是一门语言，在编译阶段和其他的编译器结构类似，只是是可定制，大致分为前端和后端，对于前端，如果是老的项目，则只需要能添砖加瓦即可，&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>优化&lt;/p>
&lt;ul>
&lt;li>优化规则
&lt;ul>
&lt;li>RBO
基于规则的优化，基于经验主义，使用之前积累的优化的可以无条件优化的规则，实质上是关系代数的等价变换，变换的目的是尽可能的在下层把无用的数据消除掉，减少不必要的数据运算
&lt;ul>
&lt;li>关系代数的优化
一些明显的可以减少运算数据的优化方法，例如谓词下推，先投影等&lt;/li>
&lt;li>子查询的优化
子查询会出现的位置是不一定的，在语句中，语义上他可以作为一张表来看，子查询分为关联子查询和非关联子查询
&lt;ol>
&lt;li>关联子查询
子查询依赖外部属性&lt;/li>
&lt;li>非关联子查询
子查询独立存在&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>优化方法
最常用的方法是通过子查询展开消除子查询，把子查询变换为连接操作，然后进行连接操作的优化，如果没有聚合操作，大部分的语句可以优化&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>谓词重写
对于一些谓词，使用其他等价规则重写，目的是为了更好的进行优化，例如like重写为大于and小于，in重写添加查询范围，any和all添加查询范围等。&lt;/li>
&lt;li>条件化简
目的是简化查询条件，便于优化，必要的时候需要重写表达式或者添加一些表达式&lt;/li>
&lt;li>视图重写&lt;/li>
&lt;li>连接消除
&lt;ul>
&lt;li>外连接消除
原因是外连接的连接顺序是不可变的，所以尽可能的把外连接转换为内连接，可转换的条件是可空侧没有null值输出，则可以直接转换为内连接，例如可空侧使用is not null 限制，&lt;/li>
&lt;li>内连接&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>join
&lt;ul>
&lt;li>left join&lt;/li>
&lt;li>right join&lt;/li>
&lt;li>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>CBO
基于代价的优化，由于一个逻辑算子的物理实现可能有多个物理算子，所以需要在实际的使用场景中选择合适的物理算子，且在多个表达式的情况下，每个逻辑算子的最有的执行计划可能得到的结果也不是最优的，所以一般需要考虑数据统计信息，以及环境的io情况，内存大小，是否是分布式环境等，然后使用这些信息计算出cost最小的执行计划，cost只是一个变量，目的是为了对计划可以与一个具体的衡量指标&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>优化框架 &lt;a href="https://zhuanlan.zhihu.com/p/73545345">https://zhuanlan.zhihu.com/p/73545345&lt;/a>
&lt;ul>
&lt;li>遗传算法
pg默认在表数量大于13的时候使用遗传算法，可能得到的不是最优的执行计划，他是通过组合然后按计划代价排序，然后随机变异，淘汰最差解得到最后的执行计划的，不是全局最优解，但是搜索空间小，&lt;/li>
&lt;li>自底向上
自底向上的动态规划算法，可以得到全局最优解，但是搜索空间巨大，PG只有在表数量小于13的时候使用此方法。
&lt;ol>
&lt;li>初始化叶子节点，每个节点取得当前最优执行计划&lt;/li>
&lt;li>组合每个叶子节点的得到第二层，保留每个组合&lt;/li>
&lt;li>使用第一层和第二层组合得到第三层&lt;/li>
&lt;li>重复类似的方式得到最优解，在计算N层的时候，具体选取那一层暂时没有结论&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>对于是否是order的，需要单独额外记录，否则底层选择的计划上层无法得知是否为最优的。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>system R
也是一种自底向上，但是只保留最优和次优解，用于上层的执行计划的生成，最后的执行计划可能不是全局最优&lt;/li>
&lt;li>Volcano [The Volcano Optimizer Generator: Extensibility and Efficient Search http://www.cse.iitb.ac.in/infolab/Data/Courses/CS632/Papers/Volcano-graefe.pdf]&lt;/li>
&lt;li>Cascades
&lt;ul>
&lt;li>expression
有逻辑表达式和物理表达式，他们在group中是等价的&lt;/li>
&lt;li>group
等价表达式的集合，等价的意思是他们的输入和输出是一样的&lt;/li>
&lt;li>rule
对group的变换规则，有物理算子的实现规则，有逻辑算子的转换规则，目的是为了扩大搜索空间&lt;/li>
&lt;li>memo
搜岁空间，存放group&lt;/li>
&lt;/ul>
&lt;ol>
&lt;li>首先初始化搜索空间，即初始化所有group&lt;/li>
&lt;li>从根节点开始，然后使用rule扩展搜索空间&lt;/li>
&lt;li>使用dfs搜索&lt;/li>
&lt;li>可以设置代价阈值，搜索时间限制等，使优化过程提前终止&lt;/li>
&lt;li>可以自行指定执行计划&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>启发式&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>执行&lt;/p>
&lt;ul>
&lt;li>
&lt;p>算子实现&lt;/p>
&lt;ul>
&lt;li>join
&lt;ul>
&lt;li>merge join&lt;br>
如果表是有序的，则优先选择merge join，否则数据无序且强行走merge join的话，会导致数据进行排序，可能会有极大的性能损耗&lt;/li>
&lt;li>hash join
&lt;ol>
&lt;li>小表作为驱动表，构造hash表，然后使用此hash表对另一个表进行hash，如果存在，则匹配成功，此步称为probe|探测。代价主要是两个表的full scan和hash表的内存以及建立hash 的时间&lt;/li>
&lt;li>如果都是大表且内存无法方法构建之后的hash表，有几种方法
&lt;ol>
&lt;li>先对原表进行分区，然后再对各个分区单独进行hash匹配，相比之前，代价是被驱动表的full scan*n 和驱动表的scan和内存损耗&lt;/li>
&lt;li>同时对两表使用相同的分区方式进行分区，然后在各自的分区内进行hash，相比上面的方法，这里可以使用多线程或者多进程进行处理&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>nest loop join&lt;br>
小表驱动大表，小表读取一行数据之后，使用此行数据到被驱动表进行匹配，所以如果被驱动表的对应的键只是普通的键的话，可能会全表扫面，所以需要被驱动表有index或者键是主键等可以直接按照key定位数据的表，代价为n*m + n&lt;/li>
&lt;li>如过是分布式的环境，则可能有数据的跨界点的传输的情况，有一张IO时间的表格表示，网络io的时间是非常长的，所以需要尽可能的保证数据在当前节点进行计算。如果必须传输数据，则
&lt;ol>
&lt;li>小表进行广播，各节点使用小表join&lt;/li>
&lt;li>常规的join运算&lt;br>
但是如果在表分区的是否，可以保证join的数据在同于一个分区上是相同的分区方式，则可以直接本节点join然后汇总数据，clickhouse的分区可以实现这种需求，分区对其&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>sort&lt;br>
排序，数据是按块操作的，可以使用merge sort，也可以通过在内存中构造一个有序的数据结构然后输出，如果内存放不下数据，则可以把数据临时放在内存外，另外，由于是按块操作的，所以可以在块中存放当前块的min max，可以使用此信息加速排序等。&lt;/li>
&lt;li>窗口函数&lt;br>
&lt;a href="https://zhuanlan.zhihu.com/p/80051518">https://zhuanlan.zhihu.com/p/80051518&lt;/a>&lt;/li>
&lt;li>常规函数&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>执行框架&lt;/p>
&lt;ul>
&lt;li>火山模型/Volcano&lt;br>
每个算子实现next，open,close方法，tuple-at-a-time类似于迭代器，用于向上层节点向下层节点拉取数据，早期cpu和mem的新能还在增长所以当时这种技术几乎是首选，运行是时间耗时主要为io，且由于大量next的调用，都会导致流水线被破坏。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>向量化&lt;br>
简单理解就是每个算子批量处理数据，早期的Volcano 模型的单行处理，会导致缓存，指令调度，分支预测错误等导致性能下降，在TP的场景中最为明显，因为AP是行存的，所以为了解决这些问题， MonetDB/X100: Hyper-Pipelining Query Execution提出vector-at-a-time执行模式，大致方向为：&lt;/p>
&lt;ul>
&lt;li>保持Volcano模型大致结构基本不变，但是原来的tuple保存一行的操作使用vector替代，保存列，数据大小尽量可以都放在缓存中 &lt;br>
所以他更多的适用于列存，行存也可以使用类似的方法来加速，但是可能效果没有列存优秀&lt;/li>
&lt;li>使用向量化原语计算&lt;br>
上下文无关的计算逻辑，专门计算vector的数据&lt;/li>
&lt;li>使用延迟物化技术减少内存的读写开销&lt;br>
记录vector中的数据变动，尽可能晚的变动内存中的数据&lt;/li>
&lt;li>使用代码生成来避免类型转换代码的大量代码分支&lt;/li>
&lt;li>CPU在计算同类型数据的时候更容易使用simd优化&lt;br>
TIPS:
&lt;ol>
&lt;li>分支预测，局部性原理，会预加载多条指令，在遇到代码跳转的时候，清空当前流水线，加载其他流水线，导致性能问题，典型的场景是排序一组有序数据和无序数据之间的差距明显&lt;/li>
&lt;li>cache miss，使用的数据不在缓存中，需要去内存中读取，记得之前有测试AOS，SOA之间的差距可以达到四五倍&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>codegen&lt;br>
把执行计划中不需要物化的算子实现为一个表达式，而不是以task的方式调度，具体实现为：&lt;/p>
&lt;ol>
&lt;li>对于算子树，使用深度优先遍历，生成一段代码&lt;/li>
&lt;li>对于Volcano模型来说，就是task算子的调用层级是现在一段代码逻辑中&lt;/li>
&lt;li>数据流动的时候可以直接存储在寄存器中，而不需要物化操作&lt;/li>
&lt;li>对于block算子，则必须物化&lt;/li>
&lt;li>由底层节点开始，向上推送数据&lt;/li>
&lt;li>适合计算场景，可以优化代码，提升寄存器的利用率&lt;/li>
&lt;/ol>
&lt;p>所以对于一个执行计划，codegen的就是把他实现为一个整体，而不是Volcano类似的面对对象的实现&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>[Everything You Always Wanted to Know About Compiled and Vectorized Queries But Were Afraid to Ask https://www.bilibili.com/video/av50329586/]
案例：
tidb使用的是向量化，即使它使用的是行存，他会在数据读取出来之后转换数据模式为vector，以便于使用向量化&lt;/p>
&lt;/li>
&lt;li>
&lt;p>存储&lt;/p>
&lt;ul>
&lt;li>存储格式
&lt;ul>
&lt;li>行存&lt;/li>
&lt;li>列存&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>存储的数据结构 【LSM &lt;a href="https://www.yuque.com/earayu/kkdi0n/gqibsf#pSa3E">https://www.yuque.com/earayu/kkdi0n/gqibsf#pSa3E&lt;/a>】&lt;br>
LSM&lt;br>
* 起源&lt;br>
- B+tree的异地更新，定期合并，垃圾回收，顺序写，最先由PG实现，但是由于实现复杂，所以后续的LSM重新设计了数据结构&lt;br>
* 数据分层&lt;br>
使用sstable保存数据，在内存中是memetable，在磁盘中是sstable，磁盘中sstable只是写，达到一定大小的时候和下层进行合并，典型的实现是leveldb&lt;br>
* 写&lt;br>
保证数据安全，先写wal&lt;br>
写内存中的memtable，当数据满之后。固化memtable&lt;br>
memtable落盘，落盘成功之后释放之前的WAL&lt;br>
如果此时磁盘中顶层的数据达到限定的阈值，则挑选一个sstable向下层compact，直到所有层都满足要求&lt;br>
* 读&lt;br>
从内存中的memtable读取数据&lt;br>
内存中没有则在磁盘中按层次查找&lt;br>
sstable可以使用额外的信息加速查找&lt;br>
* 问题&lt;br>
在写的时候会有多次IO操作，如果后台进行compact的时候，会导致前端的吞吐量，查询的时候会由读放大问题。&lt;br>
LSM 优化&lt;br>
LSM适用于HDD，当前SSD中随机读写和顺序读写几乎无太大差距&lt;br>
B+tree&lt;br>
* 起源&lt;br>
目的是为了降低从磁盘中查询数据时候的次数&lt;br>
* 组织结构&lt;br>
按页大小为单位组织节点，逻辑上的树形结构，树的高度与数据的多少有关，节点满的时候进行分裂&lt;br>
* 操作&lt;br>
读取的时候按页读取，从根节点开始，定位到子页的时候再去读取子叶，直到叶子节点被读取，页的大小是4KB，假设key为8，地址大小为8，则一组key大小为16，则一页可以指向256页，则两层树高的树可以保存1kw的数据，此时磁盘io只有三次&lt;br>
写的时候会检测节点时候full，如果full，则需要split，如果当前层满了，则增加树的高度，&lt;br>
* 随机读性能高。如果没有额外的设计，则没有读写放大的问题，且易于实现lock，但是由于写的时候可能会导致树的变化，会有性能问题&lt;/li>
&lt;li>事务
&lt;ul>
&lt;li>特性ACID
&lt;ul>
&lt;li>
&lt;p>A 原子性&lt;/p>
&lt;/li>
&lt;li>
&lt;p>C 一致性&lt;/p>
&lt;/li>
&lt;li>
&lt;p>I 隔离性&lt;/p>
&lt;ul>
&lt;li>隔离级别&lt;/li>
&lt;/ul>
&lt;ul>
&lt;li>读未提交
&lt;ul>
&lt;li>脏读
&lt;ul>
&lt;li>长时间持有写锁，短时间持有读锁，只能读取别人已经释放锁的数据&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>读已提交
&lt;ul>
&lt;li>不可重复读
&lt;ul>
&lt;li>长时间持有读锁和写锁，保持数据独占&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>快照都&lt;/li>
&lt;li>可重复读
&lt;ul>
&lt;li>幻读&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>串行化&lt;/li>
&lt;li>写偏序
&lt;ul>
&lt;li>另一个事务修改数据，导致某事物在处理的数据的时候约束条件改变&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>D 持久性&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>案例&lt;/p>
&lt;ul>
&lt;li>leveldb&lt;/li>
&lt;li>pg&lt;/li>
&lt;li>trafodion&lt;/li>
&lt;li>mysql&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>linux [2 天整理知识列表 https://www.bookstack.cn/books/webxiaohua-gitbook]&lt;/p>
&lt;ul>
&lt;li>
&lt;p>进程，线程
可以通过init创建，也可以使用fork从父进程创建，fork返回值为0，则是子进程，子进程创建的时候使用写拷贝技术，初始化的时候除了pcb之外，其余的内存呢地址和父进程是一起的，只有当子进程需要修改的时候，才会copy修改为到自己的内存中去，&lt;/p>
&lt;ul>
&lt;li>调度方法
抢占式和非抢占式
时间片
先进先出
短作业优先
长作业优先
最短剩余时间优先等&lt;/li>
&lt;li>通信&lt;/li>
&lt;li>内存结构
&lt;ul>
&lt;li>虚拟内存
为了给进程提供一个连续的内存空间，逻辑上连续，物理上不一定连续，由于进程的使用会申请和释放空间且空间有有限的，所以需要把一些页面置换出去
&lt;ol>
&lt;li>最佳置换
把以后不会使用的页面置换掉，但是无法实现，不能保证那些页面不会使用&lt;/li>
&lt;li>先进先出&lt;/li>
&lt;li>时钟置换&lt;/li>
&lt;li>最近最久未使用
置换最长时间没有使用的页面
局部性原理，时间局部性和空间局部性，在操作各种资源的时候，可以把当前资源附近的资源一起使用，附近可以是空间，也可以是时间&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>共享内存
所有页面都映射到相同的内存空间，多进程使用的时候存在竞争问题&lt;/li>
&lt;li>内存碎片
内存可能会导致总体空足够，但是无法申请空间的问题，所以需要较为合适的内存分配算法，内存一般使用链表或者其他类似的数据结构维护
&lt;ol>
&lt;li>首次适应
从链表的首段开始找到合适的内存&lt;/li>
&lt;li>最佳适应
从链表的首段开始，找到最合适的空间&lt;/li>
&lt;li>最大适应
查找到最大的内存空间，从他上面分配内存&lt;/li>
&lt;li>临近适应
从当前的使用位置开始，寻找合适的空间&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>进程间通信
&lt;ul>
&lt;li>线程由于公用地址空间，所以线程可以直接通信，进程由于资源隔离，所以需要额外的通信机制
&lt;ol>
&lt;li>匿名管道
存在在父子进程中，因为fork之后的父子进程具有相同的内存印象，所以可以直接使用&lt;/li>
&lt;li>命名管道
有名的管道，知道名字之后任意进程可以直接使用 mkfifo&lt;/li>
&lt;li>消息队列
一个本质时存放在内核中的链表，消息发送和取消的时候遵循先进先出&lt;/li>
&lt;li>共享内存
所有进程都会映射共享内存，所以可以借助它进行通信&lt;/li>
&lt;li>信号量&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>协程
简单的理解就是函数调用的状态机？他会记录运行时的状态，在多个执行线路之间进行跳转。一种实现思路时使用堆区维护协程运行context，然后在协程调用的时候记录信息即可。出现时间早，C++最早面世的时候时支持协程的，d大致是在1980s左右，因为当时计算机没有线程的实现，而进程并发代价大，所以协程-用户态线程就出现了，&lt;/p>
&lt;/li>
&lt;li>
&lt;p>IO多路复用
单线程同时检测多io
select
底层使用数组保存fd，默认大小为1024，所以有操作上限，在使用的时候需要把数组从内核拷贝到用户空间
poll
对select 的改进，底层替换为链表，使用的时候，需要遍历链表
epoll
使用回调机制，当io完成之后放入就绪链表，使用预先注册的回调函数通知用户&lt;/p>
&lt;/li>
&lt;li>
&lt;p>线程
资源使用的基本单位，进程中的线程公用地址空间，生命周期和进程有关，运行时每一个线程都有自己的运行栈&lt;/p>
&lt;/li>
&lt;li>
&lt;p>同步/异步&lt;/p>
&lt;/li>
&lt;li>
&lt;p>并发/并行&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>分布式 [2 天整理知识列表]&lt;/p>
&lt;ul>
&lt;li>共识协议
&lt;ul>
&lt;li>raft&lt;/li>
&lt;li>posie&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>大数据 [2 天整理知识列表]&lt;/p>
&lt;ul>
&lt;li>Hadoop&lt;/li>
&lt;li>spark&lt;/li>
&lt;li>hdfs&lt;/li>
&lt;li>hive&lt;/li>
&lt;li>scala&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>项目经历 [1 天整理知识列表] &amp;ndash; 大厂扯皮必备&lt;/p>
&lt;ul>
&lt;li>
&lt;p>分区表
range分区，负责index的维护，split分区，同时后期维护整个分区表的dml实现&lt;/p>
&lt;ul>
&lt;li>index
&lt;ul>
&lt;li>global index
一个分区表对应一个index，在使用的时候，例如index的全表查询等，就会使用GI&lt;/li>
&lt;li>local index
一个分区对应一个index，在查询单个分区的时候，就会使用此index&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>split
分裂分区，要求可以分裂任意分区，包括混合分区&lt;/li>
&lt;li>dml
&lt;ul>
&lt;li>
&lt;p>select
分区查询，按照查询条件决定从那个分区查询，有跨分区的情况&lt;/p>
&lt;/li>
&lt;li>
&lt;p>insert
分区insert，无法限定insert的数据来源的边界，所以需要全表的分区都进行insert&lt;/p>
&lt;/li>
&lt;li>
&lt;p>update&lt;/p>
&lt;/li>
&lt;li>
&lt;p>delete&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>临时表&lt;/p>
&lt;/li>
&lt;li>
&lt;p>只读表
数据预加载进缓存，然后从缓存读取 [
当前为只读，后期设计为懒同步，即数据访问从
]&lt;/p>
&lt;ul>
&lt;li>难点
数据存储模型
memtableDB 维护内存中的表，使用的是hash表，key为table name，values为table
- table 维护一个table对象，使用的是array，数据顺序和原表数据顺序一致
- row 行数据
内存使用
使用内置的内存池，便于计算空间使用率
多节点之间的数据同步，数据维护
* 数据预加载的时候堆表加dml和ddl锁，防止期间外部操作数据变动
* 提供数据一致性检测语法
之前设计的时候，只是想简单的比对数据
之后有一个想法，数据存储在hbase中，暂时没有找到hbase有没有所有数据的checksum实现，没有的话自行实现，然后memtable 中也实现一个checksum，比对的时候直接检测checksum即可，可以在每次查询的时候进行比对
* 原表数据变动的时候，由于存储的架构问题，所以可以完整的追踪每个数据的变化，同时计算checksum
多节点数据预加载时候的查询
存在节点重启或者节点添加或者人工运维只读表的情况，此时禁止读取，使用锁，对共享内存加锁，禁止其他任何操作&lt;/li>
&lt;li>性能
聚合语句的直接提升为上百倍&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>大字段优化&lt;/p>
&lt;ul>
&lt;li>收获最大 &amp;ndash; 假装
&lt;ul>
&lt;li>范围广，所以追踪数据流向，加快了解项目的执行逻辑&lt;/li>
&lt;li>知道了执行引擎执行逻辑 &amp;ndash; 火山模型&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>bug fix&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></content><category scheme="https://poorguyorz.github.io/posts/" term="posts" label="posts"/></entry><entry><title type="text">现代C++白皮书</title><link rel="alternate" type="text/html" href="https://poorguyorz.github.io/posts/readbooks/%E7%8E%B0%E4%BB%A3c++%E7%99%BD%E7%9A%AE%E4%B9%A6/"/><id>https://poorguyorz.github.io/posts/readbooks/%E7%8E%B0%E4%BB%A3c++%E7%99%BD%E7%9A%AE%E4%B9%A6/</id><updated>2022-05-15T14:37:51+00:00</updated><published>2022-03-06T20:46:08+08:00</published><author><name>poor Guy</name><uri>https://poorguyorz.github.io/</uri><email>a_designer@qq.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">读者序 之前没有好好的阅读过一本任何技术书籍，一般都是打开前几张，然后慢慢的失去耐心，……</summary><content type="html">&lt;h2 id="读者序">读者序&lt;/h2>
&lt;p>之前没有好好的阅读过一本任何技术书籍，一般都是打开前几张，然后慢慢的失去耐心，所有造成的问题是一些书籍上的知识，只会对前面的章节有记忆，而大多数的书籍前面的章节也只是他书籍的入门介绍而已，所以我是个半吊子程序员，工作两年半之后，这个问题越来越困扰着我，有时候看见别人的面帖，感觉那些问题其实都因该是知道答案的，但是当我想要在脑海中把答案整理出来的时候却无从说起，简单的来说就是有的东西我是知道的，但是无法表示出来，不成体系，这给我一个错觉就是我感觉我能力可以，但是落到实地的时候却啥也做不了，脱离了谷歌百度或者其他我之前的资料，我啥都不行。&lt;/p>
&lt;p>我个人觉得问题的解决方式是学会输出，把自己的知识整理输出，通过自己让别人知道一项新技能，新知识，那就代表自己其实已经有了闹靠的基础，知识的输出需要一个载体，我不是老师，公司也没有这个渠道，因为公司的知识交流与工作内容是密切相关的，所以这也是我搭建这个博客的原因，但愿我可以长期的坚持下去，说实话，之前已经有了还几次类似的经历，但是都半途而废了，我希望这是最后一次&lt;/p>
&lt;h2 id="前言">前言&lt;/h2>
&lt;p>书籍是Bjarne Stroustup为HOPL所撰写的论文，目的是介绍c++在过去到现在的发展历程，以及其中一些大的功能点的演化。促发展上来划分C++可以分为两个阶段，一是C++98之前的类C版C++，二是之后的C++11之后的现代C++，在进40年的时间里C++还没有被取代，还可以在如此多的编程语言中占据一些之地，引用Bjarne Stroustup大佬的话说就是因为他填补了编程语言中一个重要的生态位。C++的核心是直接映射硬件和林开销抽象，&lt;/p>
&lt;ul>
&lt;li>
&lt;p>ISO
编程语言可以分为三种，一是有公司主导的编程语言，例如Google的go，C#以及苹果的swift等，二是由社区主导如php，python等，这两种在除了显而易见的好处之外的，都有各自的问题，公司主导的语言的，可能哎公司强势的时候还可以得到发展，但是公司没落之后，语言没有支持可能就无了，还有那家公司主导，那语言就是那家公司的产品，技术上的map由公司指定，小公司没有能力可以影响到语言的后续发展，对于社区，则可能会由于没有一个核心的个人或者组织来引导方向，导致语言偏离最初顶下的发展道路。Bjarne Stroustup就是基于以上的原因，提出组建一个标准委员会来引导C++ 的发展，&lt;/p>
&lt;/li>
&lt;li>
&lt;p>语言特性
具体的定义的语言的规则，有对应的具体的实现&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="1-起源">1. 起源&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>C++核心特性&lt;/p>
&lt;ol>
&lt;li>语言到设备之间的直接映射&lt;/li>
&lt;li>零开销抽象
&lt;ul>
&lt;li>不使用的东西就不需要付出任何代价&lt;/li>
&lt;li>使用到的东西就是可以实现的最好的&lt;/li>
&lt;li>抽象具体为类，函数，模板，概念和别名&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>simula
最早的面向对象的语言，之后几乎所有的面向对象的语言都是直接或者间接的受奥他的印象。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>C++最初是在1979年推出的，那时候是真正的带类的C。 Bjarne Stroustup的目的是想要一个可以直接映射硬件，同时又有类似于&lt;a href="https://baike.baidu.com/item/simula">simula&lt;/a>的具有抽象能力的语言，那是一个实验性质的语言的，实现就是把编码从C++逐行翻译到C，之后的1982年，随着人数的增加，他重写了前端，实现了一个功能完整的编译器，但是实际上在代码生成的是时候，还是生成的是C，&lt;/p>
&lt;p>之后就是平稳的发展到推出98版本的C++，不考虑最近的一些新特性的话，我们大部分人的C++ 知识就到这里了。此时C++实现了&lt;/p>
&lt;ul>
&lt;li>类&lt;/li>
&lt;li>多态&lt;/li>
&lt;li>运算符重载&lt;/li>
&lt;li>类型安全连接&lt;/li>
&lt;li>抽象类&lt;/li>
&lt;li>模板
更好的泛型编程。大佬最初的时候使用宏实现的泛型编程&lt;/li>
&lt;li>异常&lt;/li>
&lt;li>RAII&lt;/li>
&lt;li>*_cast&lt;/li>
&lt;li>bool&lt;/li>
&lt;li>STL标准库
上述就是最初的98的C++实现的功能点，实际上也是大多是C++的开发人员知道的最详细的C++知识。之后就是漫长过渡期，直到11版本的推出，使C++进入新时代，&lt;/li>
&lt;li>06年单核处理器新能几乎不再提升，所以大部分应用开始寻找可以提升性能的编程语言，&lt;/li>
&lt;/ul>
&lt;h2 id="c11-新时代">C++11 新时代&lt;/h2>
&lt;p>许多新的特性的引入，使得C++类似一个新语言
特性如下&lt;/p>
&lt;ul>
&lt;li>内存模型
高效的为现代硬件设计的底层抽象，描述并发的基础，&lt;/li>
&lt;li>auto|declytype&lt;/li>
&lt;li>range for
更好的遍历容器&lt;/li>
&lt;li>移动语义和右值引用&lt;/li>
&lt;li>统一初始化&lt;/li>
&lt;li>nullptrt&lt;/li>
&lt;li>constexpr&lt;/li>
&lt;li>用户自定义字面量&lt;/li>
&lt;li>原始字符串字面量&lt;/li>
&lt;li>属性&lt;/li>
&lt;li>lambda表达式&lt;/li>
&lt;li>变参模板&lt;/li>
&lt;li>模板别名&lt;/li>
&lt;li>noexcept&lt;/li>
&lt;li>override和final&lt;/li>
&lt;li>static_assert&lt;/li>
&lt;li>longlong&lt;/li>
&lt;li>默认成员初始化&lt;/li>
&lt;li>enum class&lt;/li>
&lt;/ul>
&lt;p>组件如下&lt;/p>
&lt;ul>
&lt;li>智能指针 unique_ptr和shared_ptr&lt;/li>
&lt;li>atomic&lt;/li>
&lt;li>thread库&lt;/li>
&lt;li>future，promise等&lt;/li>
&lt;li>tuple&lt;/li>
&lt;li>type trait&lt;/li>
&lt;li>正则&lt;/li>
&lt;li>随机数&lt;/li>
&lt;li>时间&lt;/li>
&lt;li>容器&lt;/li>
&lt;/ul>
&lt;p>上面的东西就是后续C++在98 的基础上推出的新11功能点，在我自己写这边文档的时候，其实有些东西我是没概念的😂，这些看似不相关的东西，可以分为下面的几个大的主题&lt;/p>
&lt;ol>
&lt;li>并发支持&lt;/li>
&lt;li>简化使用&lt;/li>
&lt;li>泛型编程的改进&lt;/li>
&lt;li>增加静态类型的安全&lt;/li>
&lt;li>支持对库的开发&lt;/li>
&lt;li>标准库组件&lt;/li>
&lt;/ol>
&lt;h3 id="1-并发支持">1. 并发支持&lt;/h3></content><category scheme="https://poorguyorz.github.io/posts/" term="posts" label="posts"/><category scheme="https://poorguyorz.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" term="读书笔记" label="读书笔记"/><category scheme="https://poorguyorz.github.io/tags/c-/" term="C++" label="C++"/></entry><entry><title type="text">Envs</title><link rel="alternate" type="text/html" href="https://poorguyorz.github.io/posts/others/envs/"/><id>https://poorguyorz.github.io/posts/others/envs/</id><updated>2022-05-15T22:37:28+08:00</updated><published>2022-02-21T19:00:25+08:00</published><author><name>poor Guy</name><uri>https://poorguyorz.github.io/</uri><email>a_designer@qq.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">hugo wget https://github.com/gohugoio/hugo/releases/download/v0.92.1/hugo_0.92.1_Linux-64bit.deb https://github.91chi.fun/https://github.com//gohugoio/hugo/releases/download/v0.92.2/hugo_extended_0.92.2_Linux-64bit.deb sudo dpkg -i hugo*.deb 140.82.113.3 aria2c -s 5 https://github.com/gohugoio/hugo/releases/download/v0.92.1/hugo_0.92.1_Linux-64bit.deb https://github.com/gohugoio/hugo/releases/download/v0.92.1/hugo_0.92.1_Linux-64bit.deb 可以使用aria2下载，ubuntu使用apt install aria……</summary><content type="html">&lt;h2 id="hugo">hugo&lt;/h2>
&lt;p>wget &lt;a href="https://github.com/gohugoio/hugo/releases/download/v0.92.1/hugo_0.92.1_Linux-64bit.deb">https://github.com/gohugoio/hugo/releases/download/v0.92.1/hugo_0.92.1_Linux-64bit.deb&lt;/a>
&lt;a href="https://github.91chi.fun/https://github.com//gohugoio/hugo/releases/download/v0.92.2/hugo_extended_0.92.2_Linux-64bit.deb">https://github.91chi.fun/https://github.com//gohugoio/hugo/releases/download/v0.92.2/hugo_extended_0.92.2_Linux-64bit.deb&lt;/a>
sudo dpkg -i hugo*.deb&lt;/p>
&lt;p>140.82.113.3&lt;/p>
&lt;p>aria2c -s 5 &lt;a href="https://github.com/gohugoio/hugo/releases/download/v0.92.1/hugo_0.92.1_Linux-64bit.deb">https://github.com/gohugoio/hugo/releases/download/v0.92.1/hugo_0.92.1_Linux-64bit.deb&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://github.com/gohugoio/hugo/releases/download/v0.92.1/hugo_0.92.1_Linux-64bit.deb">https://github.com/gohugoio/hugo/releases/download/v0.92.1/hugo_0.92.1_Linux-64bit.deb&lt;/a>&lt;/p>
&lt;p>可以使用aria2下载，ubuntu使用&lt;code>apt install aria2&lt;/code>直接安装工具，使用-s开启多路下载
aria2c -s 5 &lt;a href="https://github.com/gohugoio/hugo/releases/download/v0.92.1/hugo_0.92.1_Linux-64bit.deb">https://github.com/gohugoio/hugo/releases/download/v0.92.1/hugo_0.92.1_Linux-64bit.deb&lt;/a>&lt;/p>
&lt;p>manager用户&lt;/p>
&lt;p>&lt;a href="https://www.jianshu.com/p/a76a93e8c662">https://www.jianshu.com/p/a76a93e8c662&lt;/a>&lt;/p>
&lt;h2 id="unix">Unix&lt;/h2>
&lt;p>分区问题，集群上多块磁盘分区挂载到指定目录&lt;/p>
&lt;pre tabindex="0">&lt;code>fdisk disk 可以对一个磁盘进行分区的添加和删除等操作
p
d
w
h
&lt;/code>&lt;/pre>&lt;p>添加磁盘挂载&lt;/p>
&lt;pre tabindex="0">&lt;code>lsblk -f 查看磁盘
mkfs.xfs -f -n ftype=1 /dev/sdb1 格式化磁盘
mount /dev/sdb1 /var/lib/docker 挂载
xfs_info /dev/sdb1 | grep ftype=1
blkid /dev/sdb1 查看UUID
UUID=&amp;lt;UUID&amp;gt; /var/lib/docker xfs defaults 0 0 写进/etc/fstab
&lt;/code>&lt;/pre>&lt;p>问题&lt;code>Couldn't find device with uuid 4mhUbb-Ls1h-jp0d-JuJK-C38V-T3tX-f7s2IN&lt;/code>&lt;/p>
&lt;p>原因未知，疑似但是这个UUID是前面挂载的分区格式化之前的UUID，所以可能是挂载的时候出了什么问题，但是之前对其他机器操作无问题，此问题只出现在集群中的一两太机器上。&lt;/p>
&lt;p>解决：&lt;/p>
&lt;pre tabindex="0">&lt;code>使用 vgreduce --removemissing --verbose lvname 解决，但是需要视情况而定，需要知道自己在做什么
其中会使用的命令
lsblk
vgscan
pvscan
cat /etc/lvm/archive/* | less 查看UUID和盘符之前的关系
lvextend -L +300G /dev/mapper/centos-root 扩展分区大小
xfs_growfs /dev/mapper/centos-root 扩展且生效
lvremove /dev/mapper/centos-home 删除lv
lvcreate -L 100G -n /dev/mapper/centos-home 创建lv
mkdf.sfx /xxxx 创建文件系统
&lt;/code>&lt;/pre>&lt;p>详细储备知识 &lt;a href="https://blog.csdn.net/lemontree1945/article/details/79293390">linux 文件&lt;/a>&lt;/p>
&lt;h2 id="ubuntu安装typora">Ubuntu安装typora&lt;/h2>
&lt;p>上海无法直连外网，所以这些都需要翻墙，或者使用其他的链接方式，&lt;/p>
&lt;ol>
&lt;li>直接使用snap安装，一般情况下，Ubuntu上可以使用apt安装就使用apt安装，这样节约空间，但是无法使用apt的时候，可以尝试使用snap，不是首选，但是无法链接网络的时候，这是首选方案&lt;/li>
&lt;li>使用安装包，但是可能无法下载&lt;/li>
&lt;li>添加typora的apt源，使用apt下载，可能有网络问题&lt;/li>
&lt;/ol>
&lt;h2 id="kubelet-换包">kubelet 换包&lt;/h2>
&lt;p>&lt;a href="http://docs.kubernetes.org.cn/227.html">官网&lt;/a>&lt;/p>
&lt;h3 id="角色">角色&lt;/h3>
&lt;ul>
&lt;li>deployment
*&lt;/li>
&lt;li>replicaset&lt;/li>
&lt;li>pod&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>docker pull 172.16.1.99/postcommit/inceptor@sha256:d9a8c9c1cf4e1587e2ac468942a987ee43b92c99787f9d392b81a8e1bda26932
docker tag 3b2a1923a5d3 baisheng5:5000/transwarp/argodb-inceptor:argodb-3.2.0-final-wl
docker push baisheng5:5000/transwarp/argodb-inceptor:argodb-3.2.0-final-wl
vdevelop-shiva1-202112141040
kubectl get deployment | grep shiva
172.16.1.99/postcommit/shiva-tabletserver:vdevelop-shiva1-202112141040
172.16.1.99/postcommit/shiva-master:vdevelop-shiva1-202112141040
172.16.1.99/postcommit/shiva-webserver:vdevelop-shiva1-202112141040
&lt;/code>&lt;/pre>&lt;p>改变deployment的配置文件的镜像，他会自动重启然后拉取镜像启动服务，所以需要准备自己的镜像，一般只需要替换镜像中的一个或者几个文件，然后让k8s使用此镜像即可，但是无法直接替换镜像中的文件，需要在运行的容器中替换，然后再以此为基准建立新的镜像，然后替换&lt;/p>
&lt;p>安装最新gcc g++
&lt;a href="https://www.jianshu.com/p/">https://www.jianshu.com/p/&lt;/a>
&lt;a href="https://cloud.tencent.com/developer/article/1635218">https://cloud.tencent.com/developer/article/1635218&lt;/a>&lt;/p>
&lt;h2 id="ubuntu换源">Ubuntu换源&lt;/h2>
&lt;pre tabindex="0">&lt;code>cd /etc/apt/
sudo cp sources.list sources.list.bak
sudo vim sources.list
注意换源的版本
deb http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse
deb-src http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse
deb http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse
deb-src http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse
deb http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse
deb-src http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse
deb http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse
deb-src http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse
deb http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse
deb-src http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse
sudo apt-get update
sudo apt-get upgrade
&lt;/code>&lt;/pre>&lt;pre tabindex="0">&lt;code>sudo add-apt-repository ppa:ubuntu-toolchain-r/test
sudo apt update
sudo apt install g++-11
sudo apt install gcc-11
&lt;/code>&lt;/pre>&lt;p>export GIT_CURL_VERBOSE=1
github无法使用https拉取代码&lt;/p>
&lt;ul>
&lt;li>单机docker换源，编辑/etc/docker/daemon.json，配置为&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>{
&amp;quot;registry-mirrors&amp;quot;: [&amp;quot;https://docker.mirrors.ustc.edu.cn/&amp;quot;]
}
&lt;/code>&lt;/pre>&lt;p>然后使用systemctl daemon-reload重新加载配置，使用systemctl restart docker重启docker即可&lt;/p>
&lt;p>改变deployment的配置文件的镜像，他会自动重启然后拉取镜像启动服务，所以需要准备自己的镜像，一般只需要替换镜像中的一个或者几个文件，然后让k8s使用此镜像即可，但是无法直接替换镜像中的文件，需要在运行的容器中替换，然后再以此为基准建立新的镜像，然后替换&lt;/p>
&lt;h2 id="mysql">mysql&lt;/h2>
&lt;ul>
&lt;li>安装&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>sudo apt install mysql-server
mysql_secure_installation
&lt;/code>&lt;/pre>&lt;p>密码问题&lt;/p>
&lt;pre tabindex="0">&lt;code>/etc/mysql/mysql.conf.d/mysqld.cnf/
添加
skip-grant-tables
然后使用mysql进入mysql
主要修改user下的用户的密码字段
无法直接使用update语句，
可以使用ALTER USER 'root'@'localhost' IDENTIFIED BY '123456'; 修改
如果报权限问题，使用flush privileges;刷新在执行
之后再修改配置文件去掉添加的信息即可
密码策略，
SHOW VARIABLES LIKE 'validate_password%';查看密码策略
使用set global validate_password_length=6;修改策略
&lt;/code>&lt;/pre></content><category scheme="https://poorguyorz.github.io/posts/" term="posts" label="posts"/></entry><entry><title type="text">Docker</title><link rel="alternate" type="text/html" href="https://poorguyorz.github.io/posts/others/docker/"/><id>https://poorguyorz.github.io/posts/others/docker/</id><updated>2022-05-15T22:37:28+08:00</updated><published>2022-02-20T21:17:58+08:00</published><author><name>poor Guy</name><uri>https://poorguyorz.github.io/</uri><email>a_designer@qq.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">Docker 新公司的产品的每一个模块是单独运行在容器中的，且由于是使用Java开发的，所以需要……</summary><content type="html">&lt;h2 id="docker">Docker&lt;/h2>
&lt;p>新公司的产品的每一个模块是单独运行在容器中的，且由于是使用Java开发的，所以需要有频繁替换包的过程，之前只是简单的了解了docker，但是并没有深入的学习，这里记录docker的使用细节，以便于更好的工作，&lt;/p>
&lt;h2 id="基础概念">基础概念&lt;/h2>
&lt;p>Docker使用go开发的一种沙箱工具，他使得应用可以单独运行在沙箱中，通过端口映射或者volumes与外界进行交互。这可以让一个机器上可以运行多种不同环境的应用且互不干扰，例如一个比较大型的引用，使用的此方式单独维护一个模块，使得系统的可靠性大大增强&lt;/p>
&lt;ul>
&lt;li>容器&lt;br>
镜像运行的实例，一个镜像可以运行多个实例。&lt;/li>
&lt;li>镜像&lt;br>
一个完整的可运行的资源集合&lt;/li>
&lt;li>仓库&lt;br>
保存镜像&lt;/li>
&lt;/ul>
&lt;h2 id="使用">使用&lt;/h2>
&lt;p>这里记录高频次使用的功能，其他的后续记录&lt;/p>
&lt;ul>
&lt;li>
&lt;p>镜像的管理&lt;/p>
&lt;ul>
&lt;li>pull&lt;/li>
&lt;li>push&lt;/li>
&lt;li>commit&lt;br>
修改一个容器之后，使用commit在此基础上构建自己的容器&lt;/li>
&lt;li>build&lt;br>
创建一个镜像，使用docker build语句创建，需要自己编写Dockerfile，具体的编写规则可以参考nosipage&lt;/li>
&lt;li>rmi&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>容器的管理&lt;/p>
&lt;ul>
&lt;li>run&lt;br>
创建新的容器，且会使用run指定启动规则，例如端口的映射，volumes文件的指定，以及其他重要参数等，这个命令可以说重要，因为同一个镜像，使用不同参数启动之后，效果是不一样的，对于开发来时，更多的是参与后期的开发，如果不是前期的项目设计，这里了解即可，但是最好的是知道他的只要参数的意义，因为和其他命令有的是通用的，例如-i -t -p等&lt;/li>
&lt;li>start&lt;/li>
&lt;li>stop&lt;/li>
&lt;li>restart&lt;/li>
&lt;li>exec&lt;br>
使用此命令可以进入运行中的容器中区，exec -it xxx command&lt;/li>
&lt;li>attach&lt;/li>
&lt;li>rm&lt;/li>
&lt;li>logs&lt;/li>
&lt;li>cp&lt;br>
在本地和容器中传输文件&lt;/li>
&lt;li>export&lt;/li>
&lt;li>ps&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>其他命令基本在遇到的时候，再去查看&lt;/p></content><category scheme="https://poorguyorz.github.io/posts/" term="posts" label="posts"/><category scheme="https://poorguyorz.github.io/tags/docker/" term="Docker" label="Docker"/></entry><entry><title type="text">C++ logs</title><link rel="alternate" type="text/html" href="https://poorguyorz.github.io/posts/languange/cpp/"/><id>https://poorguyorz.github.io/posts/languange/cpp/</id><updated>2022-05-15T22:37:28+08:00</updated><published>2022-02-20T20:54:01+08:00</published><author><name>poor Guy</name><uri>https://poorguyorz.github.io/</uri><email>a_designer@qq.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">编译器 把高级语言编译成可执行语言工具，分为前端后后端，前端值得是高级语言的解析，后端……</summary><content type="html">&lt;h1 id="编译器">编译器&lt;/h1>
&lt;p>把高级语言编译成可执行语言工具，分为前端后后端，前端值得是高级语言的解析，后端是指翻译解析之后的结果为机器语言&lt;/p>
&lt;ul>
&lt;li>
&lt;p>多文件
** 连接
多文件编译可以有两种方式，一是直接编译为一个可以执行文件，二是按模块或者按文件编译为库，然后连接到执行文件&lt;/p>
&lt;ul>
&lt;li>连接方式有两种，
一是静态连接，把所有的库文件打包到最后的生成文件中，优点是不需要额外的依赖外部环境，独立性强，缺点是文件体积大
二是动态链接，为了解决静态链接的缺点，执行文件在执行到库相关的代码的时候才加载库，有一点需要注意的是，程序运行的时候，在使用到动态库的时候才映射动态库到内存空间中。原理是编译待援在编译的时候，会更具声明生成函数的调用逻辑，但是只是一个地址跳转语句，所以，只要不调用，就不会有问题，当调用到了。才会加载库然后映射库的地址，这个完整的过程称为重定向。
&lt;a href="https://joytsing.github.io/posts/59293/">动态连接&lt;/a>
&lt;a href="https://www.bookstack.cn/read/open-c-book/doc-README.md">C语言编程透视&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>声明
声明是为了在编译的时候编译器能进行完整的上下文编译。他需要更具声明来确定编译信息，否则编译器无法确定编译中的语句信息，声明可以辅助完成这个情况， 所以理论上编译的时候是可以不需要实现的，可以在其他编译单元中实现声明的函数，其声明的文件可以不引用头文件，即两个编译单元完全可以无任何联系，除了声明之外，在连接的时候，连接器会根据编译出来的信息去确定函数调用情况，这里有一个问题，按上述的描述，是一个声明对应一个实现，如果有一个声明对应多个实现呢
== ： 会有覆盖问题，如果多个动态链接库都有同一个声明的实现，则连接的时候连接第一个，后面的则忽略，这也提醒我们，在大型项目中，避免同名全局函数或者变量，使用namespace或者static限制作用域，&lt;/p>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c++" data-lang="c++">&lt;span class="n">g&lt;/span>&lt;span class="o">++&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="n">o&lt;/span> &lt;span class="n">tt&lt;/span> &lt;span class="p">..&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">main&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">cpp&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="n">ldl&lt;/span> &lt;span class="p">.&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">libhellolib&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">so&lt;/span> &lt;span class="p">.&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">libhellolib1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">so&lt;/span>
&lt;span class="n">LD_LIBRARY_PATH&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="err">$&lt;/span>&lt;span class="n">PWD&lt;/span> &lt;span class="p">.&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">tt&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>头文件，避免公用代码的重复，预处理时展开头文件，需要使用#pragma once避免重复引用，头文件只是简单的文件替换，理论上的可以替换任何文本。&lt;/li>
&lt;/ul>
&lt;p>cmake
* 子模块，使用add_subdirectory引入
* 第三方库
* 只是头文件，直接指定头文件目录编译即可
* 使用子模块
* 使用为连接库
* 使用git模块&lt;/p>
&lt;ul>
&lt;li>
&lt;p>STL&lt;/p>
&lt;ul>
&lt;li>重点为容器和算法&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>lambda表达式，实质上是仿函数，是一个结构体实现()运算的重载，捕获的时候按照声明的新式捕获参数，建议使用的时候明确使用的参数，使用哪个就捕获哪一个，否则他实际上会占据一定的大小的，配合std::function使用&lt;/p>
&lt;/li>
&lt;li>
&lt;p>CTAD &amp;mdash; complie-time argument deduction，编译器参数推断，C++17引入的，可以在编译器按照上下文推断类型，具体表现在lambda参数可以使用auto，容器可以不适用&amp;lt;&amp;gt;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>ranges
&lt;a href="https://zhuanlan.zhihu.com/p/350068132">https://zhuanlan.zhihu.com/p/350068132&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>module&lt;/p>
&lt;/li>
&lt;li>
&lt;p>raii 获取资源即初始化，释放资源即销毁，具体的实现是使用构造函数和析构函数，当前的实现为智能指针，其他用户自己管理的资源最好也使用raii，遮这样在函数有多个出口的时候，就不会有意外的情况，本质上还是自己管理资源，不想其他的语言有GC&lt;/p>
&lt;ul>
&lt;li>异常安全，C++中异常机制在回溯栈的时候会析构对象，所以如果没有实现RAII，则自己管理的内存则无法释放，C++的异常可以发生在任何地方，如果发生在析构函数中，则需要自己处理，不要在析构函数中抛出异常的，在构造函数中的时候，也需要捕获异常然后释放已经申请的资源，构造函数异常的时候，是不会调用析构函数的，&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>构造函数&lt;/p>
&lt;ul>
&lt;li>构造函数有时候会隐士的生成对象，即使没有显示声明，使用explicit避免这种情况，单参数的时候会，多参数使用{}，调用的时候也会
&lt;ul>
&lt;li>直接使用多参数的时候，()和{}是有区别的，()除了正常的使用外，其他情况不具备特殊含义&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c++" data-lang="c++"> &lt;span class="kt">int&lt;/span> &lt;span class="n">a&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="mi">10&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">11&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">a&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="mi">10&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">11&lt;/span>&lt;span class="p">};&lt;/span>
&lt;span class="n">tt&lt;/span> &lt;span class="nf">t&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ul>
&lt;p>tt q{1, 3};
tt w = {1, 4};
tests({1,5});
```
上面的语句1正确，a的值为11，2错误，{}这种用法的意义是参数列表，是会构造对象的。ps，调用构造函数的时候，有具体的对象的时候两种括号无差别，但是无对象的时候有区别，如上，细品&lt;/p>
&lt;ul>
&lt;li>默认构造函数&lt;/li>
&lt;li>拷贝构造( A(A const &amp;amp; a) ) A a = aa;&lt;/li>
&lt;li>移动构造( A(A &amp;amp;&amp;amp; a) )&lt;/li>
&lt;li>赋值构造( A&amp;amp;operator=(A const&amp;amp; a) ) A a; a = aa;&lt;/li>
&lt;li>移动赋值( A&amp;amp;operator=(A &amp;amp;&amp;amp; a) )&lt;/li>
&lt;li>=delte和=default&lt;/li>
&lt;li>类内部变量可以赋初值&lt;/li>
&lt;li>三五法则
&lt;ul>
&lt;li>拷贝构造或者赋值构造需要区分深拷贝和浅拷贝，这也是构造函数肯可能引入的问题，例如浅拷贝导致内存的重复释放，&lt;/li>
&lt;li>各种构造函数更多的是需要考虑当前对象的来源，如果是直接从零开始的，则是普通的构造函数，如果是从别的对象来的，则需要考虑深浅拷贝的问题，以及构造之后别的对象是否还需要的问题，简而言之，就是资源细节上的考虑，只要内涉及到资源的操作，则需要多话费一些心思区考虑，&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>函数返回多值&lt;/p>
&lt;ul>
&lt;li>使用结构体打包，结构体可以使用{}任意构造，且好处是可以获取变量的名字&lt;/li>
&lt;li>tuple&lt;/li>
&lt;li>pair&lt;/li>
&lt;li>各种结构方式&lt;/li>
&lt;li>结构化绑定，类似rust&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>option 成功则优质返回，否则返回nullopt，搭配has_value等使用，类似rust&lt;/p>
&lt;/li>
&lt;li>
&lt;p>variant&lt;/p>
&lt;/li>
&lt;li>
&lt;p>智能指针&lt;/p>
&lt;ul>
&lt;li>RAII的具体体现&lt;/li>
&lt;li>unique_ptr
禁止拷贝，只允许移动，避免产生多个对象&lt;/li>
&lt;li>shared_ptr
使用计数器记录对象，允许存在多个对象，相互引用问题，&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>限于篇幅，此处放出一些扩展知识供学有余力的同学研究：
P-IMPL 模式
虚函数与纯虚函数
拷贝如何作为虚函数
std::unique_ptr::release()
std::enable_shared_from_this
dynamic_cast
std::dynamic_pointer_cast
运算符重载
右值引用 &amp;amp;&amp;amp;
std::shared_ptr&lt;void>和 std::any
只提供了关键字，详细信息请善用搜索引擎：bing.com。（不要用 baidu.com，那个是搜广告用的）
如果感兴趣，我可以增添一节专门讲动态多态。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>模板&lt;/p>
&lt;ul>
&lt;li>更加广义上的重载机制，模板会在编译的时候，在依据上下文信息编译代码，调用的时候可以使用&amp;lt;&amp;gt;声明模板参数，在17之后有CTAD，可以省略这一步，直接和调用普通函数一致，但是需要明确的是他是需要从上下文进行类型的推到，如果编译时上下文无法推到类型信息，则还是需要使用尖括号，&lt;/li>
&lt;li>模板可以是CLASS或者typename，也可以是整形，例如tuple的get函数使用整形模板参数指定参数index，但是参数只能是整形，不知道是从哪里开的口子，
&lt;ul>
&lt;li>此时模板参数必须是编译期间可以确定的常量，如果是表达式，可以使用constexpri修饰，&lt;/li>
&lt;li>使用整形的一个特殊原因是由于模板参数是编译器编译期间可以确定的，则此时可以根据模板参数进行代码优化，例如函数的参数列表使用bool确定函数是否是debug模式，此时由于参数是变量，所以无法优化，必须有一个if跳转逻辑。但是假如是模板参数，则会在编译的时候确定生成的代码是什么，可以直接在代码生成的时候优化掉&lt;/li>
&lt;li>编译期常量，是编译器在编译期间的可以通过直接运算或者其他方式运算得到一个确切的值，需要使用constexpr修饰，否则即使是一个值，他也不能用在有要求的地方，例如模板参数&lt;/li>
&lt;li>模板的惰性编译，
&lt;ul>
&lt;li>模板会工具编译时候遇到的模板参数生成不同的函数，函数名字的参数类型不一样，具体可以使用objdump查看生成的函数名，所以一个模板可能有多份代码的生成，需要考虑实际的使用情况，如果一个模板没有使用到，此时他的模板参数按什么生成，所以模板是在遇到调用的时候才生成的，是惰性的，此过程隐含两个信息，一是编译的时候需要调用才生成代码，二是编译的时候能找到模板的说明代码，因为编译是分为不同的编译单元的，如果在编译模板的编译单元的时候没有发现模板调用，导致没有生成代码，其他的编译单元发现了调用，但是模板的编译单元已编译完成，所以模板需要注意的是使用的时候最好确保所有的使用的代码都能看见模板实现，简单的就是模板最好放在头文件实现，不要分开。否则需要在模板的编译单元里面添加模板参数的声明。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>auto只是推到类型，不包含引用信息和const，可以手动指定&lt;/p>
&lt;/li>
&lt;li>
&lt;p>if constexpr&lt;/p>
&lt;/li>
&lt;li>
&lt;p>int&amp;amp; int&amp;amp;&amp;amp; const int &amp;amp;&lt;/p>
&lt;ul>
&lt;li>常饮用范围最小，其他两种引用都可以转换为长应用&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></content><category scheme="https://poorguyorz.github.io/posts/" term="posts" label="posts"/><category scheme="https://poorguyorz.github.io/tags/test_tag/" term="test_tag" label="test_tag"/><category scheme="https://poorguyorz.github.io/tags/asd/" term="asd" label="asd"/></entry><entry><title type="text">Hello World</title><link rel="alternate" type="text/html" href="https://poorguyorz.github.io/posts/others/hello-world/"/><id>https://poorguyorz.github.io/posts/others/hello-world/</id><updated>2022-05-15T22:37:28+08:00</updated><published>2022-02-07T03:54:01+08:00</published><author><name>poor Guy</name><uri>https://poorguyorz.github.io/</uri><email>a_designer@qq.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.
Quick Start Create a new post 1 $ hexo new &amp;#34;My New Post&amp;#34; More info: Writing</summary><content type="html">&lt;p>Welcome to &lt;a href="https://hexo.io/">Hexo&lt;/a>! This is your very first post. Check &lt;a href="https://hexo.io/docs/">documentation&lt;/a> for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href="https://hexo.io/docs/troubleshooting.html">troubleshooting&lt;/a> or you can ask me on &lt;a href="https://github.com/hexojs/hexo/issues">GitHub&lt;/a>.&lt;/p>
&lt;h2 id="quick-start">Quick Start&lt;/h2>
&lt;h3 id="create-a-new-post">Create a new post&lt;/h3>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">$ hexo new &lt;span class="s2">&amp;#34;My New Post&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>More info: &lt;a href="https://hexo.io/docs/writing.html">Writing&lt;/a>&lt;/p>
&lt;h3 id="run-server">Run server&lt;/h3>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">$ hexo server
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>More info: &lt;a href="https://hexo.io/docs/server.html">Server&lt;/a>&lt;/p>
&lt;!-- more -->
&lt;h3 id="generate-static-files">Generate static files&lt;/h3>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">$ hexo generate
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>More info: &lt;a href="https://hexo.io/docs/generating.html">Generating&lt;/a>&lt;/p>
&lt;h3 id="deploy-to-remote-sites">Deploy to remote sites&lt;/h3>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">$ hexo deploy
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>More info: &lt;a href="https://hexo.io/docs/one-command-deployment.html">Deployment&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c++" data-lang="c++">&lt;span class="n">sssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="nf">main&lt;/span> &lt;span class="p">();&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>$f(x) = a+b$&lt;/p>
&lt;p>​
This is my first post on the site. I hope that you like it!
​&lt;/p>
&lt;h2 id="welcome-function">Welcome Function&lt;/h2>
&lt;p>​
Here is a little Python function to welcome you:
​
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="k">def&lt;/span> &lt;span class="nf">hello_world&lt;/span>&lt;span class="p">():&lt;/span>
&lt;span class="nb">print&lt;/span> &lt;span class="s2">&amp;#34;Hello there!&amp;#34;&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="k">def&lt;/span> &lt;span class="nf">hello_world&lt;/span>&lt;span class="p">():&lt;/span>
&lt;span class="nb">print&lt;/span> &lt;span class="s2">&amp;#34;Hello there!&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div></content><category scheme="https://poorguyorz.github.io/posts/" term="posts" label="posts"/><category scheme="https://poorguyorz.github.io/tags/test_tag/" term="test_tag" label="test_tag"/><category scheme="https://poorguyorz.github.io/tags/asd/" term="asd" label="asd"/></entry></feed>