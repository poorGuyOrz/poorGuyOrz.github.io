<?xml version="1.0" encoding="utf-8"?><rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>Wakak</title><link>https://poorguyorz.github.io/</link><description>A Test Blog</description><generator>Hugo 0.92.1 https://gohugo.io/</generator><language>zh-CN</language><managingEditor>a_designer@qq.com (Wakaka)</managingEditor><webMaster>a_designer@qq.com (Wakaka)</webMaster><copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright><lastBuildDate>Sat, 28 May 2022 07:46:30 +0000</lastBuildDate><atom:link rel="self" type="application/rss+xml" href="https://poorguyorz.github.io/rss.xml"/><item><title>A Tour of Go速通</title><link>https://poorguyorz.github.io/posts/languange/go_1/</link><guid isPermaLink="true">https://poorguyorz.github.io/posts/languange/go_1/</guid><pubDate>Tue, 17 May 2022 22:34:11 +0800</pubDate><author>a_designer@qq.com (Wakaka)</author><copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright><description>2022-05-17 基础语法 2022-05-24 复合类型，goroutine，channel 基础语法 Packages go使用Packages维护模块，使用import导入模块，import最后一个元素才是需要导入的模块
1 2 3 4 import ( &amp;#34;fmt&amp;#34; &amp;#34;math/rand&amp;#34; ) import 可以单独一个导入一个模块，也可以批量导入， 与之对应的是export，go不显示声明export，首字母大写的变量或方法自动export，外部只能使用导出的变量或者方法，类似c++中类的私有和共有的概念。
Functions 与c++或者Java或者其他语言不同的是，go的函数签名格式为func func_name(parm1 [type], parm2 [type]....) retype {}，先声明名字，再声明变量的类型，参数列表中有多个参数且类型一致的时候，前面的参数类型可以省略，只需要保留之后一个
1 2 3 func add(x, y int) int { return x + y } 且go可以很轻易的实现多返回值的功能，如下</description></item><item><title>LevelDB源码阅读</title><link>https://poorguyorz.github.io/posts/readbooks/leveldb/</link><guid isPermaLink="true">https://poorguyorz.github.io/posts/readbooks/leveldb/</guid><pubDate>Sun, 15 May 2022 21:59:53 +0800</pubDate><author>a_designer@qq.com (Wakaka)</author><copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright><description>read: d019e3605f222ebc5a3a2484a2cb29db537551dd 小且完整的工业存储实现，其中有许多细节是可以借鉴的。这里没有完整的深入每一行代码，后续会时不时的慢慢补充
2022-05-17 初步阅读代码，了解组件及大致执行逻辑 编译 1 2 git clone --recurse-submodules https://github.com/google/leveldb.git cd leveldb VSCode安装cmake插件之后，打开项目，cmake插件自动配置，此时使用shift+p设置cmake: set build target之后，再使用shift+p选择cmake: build即可编译目标模块，d019e3605f222ebc5a3a2484a2cb29db537551dd中测试文件进行了调整，全部合并到leveldb_tests中，调试时按照想要了解的模块，自己注释其他测试文件，重新编译即可。此时可以在文件中断点调试，或者使用gdb调试
slice 字符串的浅拷贝实现，使用一个指针和指针长度实现，类似c++后来实现的string_view，如果使用string，则在传递数据的时候会进行拷贝操作，有性能损失。另一个目的是为了自主可控，确保数据在传输的过程中不会造成太多的数据副本。所以拷贝构造函数使用的是默认的系统函数，使用浅拷贝
1 2 Slice(const Slice&amp;amp;) = default; Slice&amp;amp; operator=(const Slice&amp;amp;) = default; status 自定义信息模块，把状态码和状态信息进行压缩，压缩格式如下</description><category domain="https://poorguyorz.github.io/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/">源码阅读</category><category domain="https://poorguyorz.github.io/tags/leveldb/">LevelDB</category></item><item><title>VolcanoOptimizer</title><link>https://poorguyorz.github.io/posts/readbooks/volcanooptimizer/</link><guid isPermaLink="true">https://poorguyorz.github.io/posts/readbooks/volcanooptimizer/</guid><pubDate>Mon, 04 Apr 2022 22:10:50 +0800</pubDate><author>a_designer@qq.com (Wakaka)</author><copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright><description>NOTE 论文阅读笔记The Volcano Optimizer Generator: Extensibility and Efficient Search
可扩展
面向对象
自顶向下
剪枝
原型是EXODUS， Volcano是对他的改进
可以单独使用的优化器 优化搜索时间和搜索空间 可扩展 可以使用启发式算法和有效的代价模型来扩展和减少搜索空间，【剪枝】 灵活的成本计算模型 一个框架，优化器生成器，可以由“optimizer implementor”自行实现关键函数，整个优化器框架的输入是AST，输出是一个执行计划，算子的集合
SQL是基于关系代数，Volcano把关系表达式分为逻辑表达式和物理表达式，逻辑表达式之间使用transformation进行转换，物理表达式使用基于代价的implementation和逻辑表达式映射的，关系不一定是意义对应的，例如scan可以同时一起实现projection
在表达式进行转换的时候可以使用condition进行模式判断，满足条件的时候可以进行变换</description></item><item><title>Columbia Optimizer</title><link>https://poorguyorz.github.io/posts/readbooks/columbia-optimizer/</link><guid isPermaLink="true">https://poorguyorz.github.io/posts/readbooks/columbia-optimizer/</guid><pubDate>Sat, 02 Apr 2022 16:55:12 +0800</pubDate><author>a_designer@qq.com (Wakaka)</author><copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright><description>start EFFICIENCY IN THE COLUMBIA DATABASE QUERY OPTIMIZER
优化器发展版本 第一代
模块化的，分层的，可扩展的，基于规则的优化器 扩展的复杂性，搜索性能 第二代
类似Volcano，更加优秀的优化规则，且使用物理属性参与优化，使用新的搜索方式 更加灵活，但是还是难与扩展 第三代
使用面对象的思想实现的优化器，易于扩展，更灵活 可以按照搜索策略分为两类 1. 自底向上 2. 自顶向下 Cascades Optimizer Framework 对关键操作定义为抽象类，通过实现抽象类来添加规则或者进行表达式变换来扩展优化器， * 使用hash来消除重复的表达式 * 再group中把逻辑表达式和物理表达式分开 * 剪枝 先计算上层group的cost 阈值，在计算下层节点的时候，直接判断是否还需要继续进行优化 预先对执行计划设置阈值，当执行计划的代价和阈值足够接近的时候，则判定已完成搜索</description></item><item><title>面试</title><link>https://poorguyorz.github.io/posts/bigdata/log/</link><guid isPermaLink="true">https://poorguyorz.github.io/posts/bigdata/log/</guid><pubDate>Thu, 24 Mar 2022 20:26:11 +0800</pubDate><author>a_designer@qq.com (Wakaka)</author><copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright><description>面试 只是一个技术汇总
C++基础 [2 days] [课程- https://github.com/parallel101/course.git]
内存 内存结构 [https://segmentfault.com/a/1190000039348996]
c++ 编译出来的是可执行文件，是ELF格式的，他本来就有一些格式上的划分，C++在他的基础上进行了更细的划分，分为五个部分，从高地址到底地址依次为： 1. 内核虚拟内存 进程的虚拟印象 2. 栈 程序自动控制，具体为程序的函数调用，保存局部变量，有大小，可以使用ulimit -s 查看，也可以自行设置，但是建议系统默认即可 * 函数调用机制 调用的时候是一个一个的栈帧，函数参数会在调用者的栈帧中开辟空间，从右到左，所以函数列表的默认值必须从右到左的初始化， 可能和这个有关系，然后被调用者构造栈帧，依次执行 3.</description></item><item><title>现代C++白皮书</title><link>https://poorguyorz.github.io/posts/readbooks/%E7%8E%B0%E4%BB%A3c++%E7%99%BD%E7%9A%AE%E4%B9%A6/</link><guid isPermaLink="true">https://poorguyorz.github.io/posts/readbooks/%E7%8E%B0%E4%BB%A3c++%E7%99%BD%E7%9A%AE%E4%B9%A6/</guid><pubDate>Sun, 06 Mar 2022 20:46:08 +0800</pubDate><author>a_designer@qq.com (Wakaka)</author><copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright><description>读者序 之前没有好好的阅读过一本任何技术书籍，一般都是打开前几张，然后慢慢的失去耐心，所有造成的问题是一些书籍上的知识，只会对前面的章节有记忆，而大多数的书籍前面的章节也只是他书籍的入门介绍而已，所以我是个半吊子程序员，工作两年半之后，这个问题越来越困扰着我，有时候看见别人的面帖，感觉那些问题其实都因该是知道答案的，但是当我想要在脑海中把答案整理出来的时候却无从说起，简单的来说就是有的东西我是知道的，但是无法表示出来，不成体系，这给我一个错觉就是我感觉我能力可以，但是落到实地的时候却啥也做不了，脱离了谷歌百度或者其他我之前的资料，我啥都不行。
我个人觉得问题的解决方式是学会输出，把自己的知识整理输出，通过自己让别人知道一项新技能，新知识，那就代表自己其实已经有了闹靠的基础，知识的输出需要一个载体，我不是老师，公司也没有这个渠道，因为公司的知识交流与工作内容是密切相关的，所以这也是我搭建这个博客的原因，但愿我可以长期的坚持下去，说实话，之前已经有了还几次类似的经历，但是都半途而废了，我希望这是最后一次
前言 书籍是Bjarne Stroustup为HOPL所撰写的论文，目的是介绍c++在过去到现在的发展历程，以及其中一些大的功能点的演化。促发展上来划分C++可以分为两个阶段，一是C++98之前的类C版C++，二是之后的C++11之后的现代C++，在进40年的时间里C++还没有被取代，还可以在如此多的编程语言中占据一些之地，引用Bjarne Stroustup大佬的话说就是因为他填补了编程语言中一个重要的生态位。C++的核心是直接映射硬件和林开销抽象，
ISO 编程语言可以分为三种，一是有公司主导的编程语言，例如Google的go，C#以及苹果的swift等，二是由社区主导如php，python等，这两种在除了显而易见的好处之外的，都有各自的问题，公司主导的语言的，可能哎公司强势的时候还可以得到发展，但是公司没落之后，语言没有支持可能就无了，还有那家公司主导，那语言就是那家公司的产品，技术上的map由公司指定，小公司没有能力可以影响到语言的后续发展，对于社区，则可能会由于没有一个核心的个人或者组织来引导方向，导致语言偏离最初顶下的发展道路。Bjarne Stroustup就是基于以上的原因，提出组建一个标准委员会来引导C++ 的发展，
语言特性 具体的定义的语言的规则，有对应的具体的实现
1. 起源 C++核心特性
语言到设备之间的直接映射 零开销抽象 不使用的东西就不需要付出任何代价 使用到的东西就是可以实现的最好的 抽象具体为类，函数，模板，概念和别名 simula 最早的面向对象的语言，之后几乎所有的面向对象的语言都是直接或者间接的受奥他的印象。
C++最初是在1979年推出的，那时候是真正的带类的C。 Bjarne Stroustup的目的是想要一个可以直接映射硬件，同时又有类似于simula的具有抽象能力的语言，那是一个实验性质的语言的，实现就是把编码从C++逐行翻译到C，之后的1982年，随着人数的增加，他重写了前端，实现了一个功能完整的编译器，但是实际上在代码生成的是时候，还是生成的是C，</description><category domain="https://poorguyorz.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</category><category domain="https://poorguyorz.github.io/tags/c-/">C++</category></item><item><title>Envs</title><link>https://poorguyorz.github.io/posts/others/envs/</link><guid isPermaLink="true">https://poorguyorz.github.io/posts/others/envs/</guid><pubDate>Mon, 21 Feb 2022 19:00:25 +0800</pubDate><author>a_designer@qq.com (Wakaka)</author><copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright><description>hugo wget https://github.com/gohugoio/hugo/releases/download/v0.92.1/hugo_0.92.1_Linux-64bit.deb https://github.91chi.fun/https://github.com//gohugoio/hugo/releases/download/v0.92.2/hugo_extended_0.92.2_Linux-64bit.deb sudo dpkg -i hugo*.deb
140.82.113.3
aria2c -s 5 https://github.com/gohugoio/hugo/releases/download/v0.92.1/hugo_0.92.1_Linux-64bit.deb
https://github.com/gohugoio/hugo/releases/download/v0.92.1/hugo_0.92.1_Linux-64bit.deb
可以使用aria2下载，ubuntu使用apt install aria2直接安装工具，使用-s开启多路下载 aria2c -s 5 https://github.com/gohugoio/hugo/releases/download/v0.92.1/hugo_0.92.1_Linux-64bit.deb
manager用户
https://www.jianshu.com/p/a76a93e8c662
Unix 分区问题，集群上多块磁盘分区挂载到指定目录
fdisk disk 可以对一个磁盘进行分区的添加和删除等操作 p d w h 添加磁盘挂载
lsblk -f 查看磁盘 mkfs.xfs -f -n ftype=1 /dev/sdb1 格式化磁盘 mount /dev/sdb1 /var/lib/docker 挂载 xfs_info /dev/sdb1 | grep ftype=1 blkid /dev/sdb1 查看UUID UUID=&amp;lt;UUID&amp;gt; /var/lib/docker xfs defaults 0 0 写进/etc/fstab 问题Couldn't find device with uuid 4mhUbb-Ls1h-jp0d-JuJK-C38V-T3tX-f7s2IN</description></item><item><title>Docker</title><link>https://poorguyorz.github.io/posts/others/docker/</link><guid isPermaLink="true">https://poorguyorz.github.io/posts/others/docker/</guid><pubDate>Sun, 20 Feb 2022 21:17:58 +0800</pubDate><author>a_designer@qq.com (Wakaka)</author><copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright><description>Docker 新公司的产品的每一个模块是单独运行在容器中的，且由于是使用Java开发的，所以需要有频繁替换包的过程，之前只是简单的了解了docker，但是并没有深入的学习，这里记录docker的使用细节，以便于更好的工作，
基础概念 Docker使用go开发的一种沙箱工具，他使得应用可以单独运行在沙箱中，通过端口映射或者volumes与外界进行交互。这可以让一个机器上可以运行多种不同环境的应用且互不干扰，例如一个比较大型的引用，使用的此方式单独维护一个模块，使得系统的可靠性大大增强
容器
镜像运行的实例，一个镜像可以运行多个实例。 镜像
一个完整的可运行的资源集合 仓库
保存镜像 使用 这里记录高频次使用的功能，其他的后续记录
镜像的管理
pull push commit
修改一个容器之后，使用commit在此基础上构建自己的容器 build
创建一个镜像，使用docker build语句创建，需要自己编写Dockerfile，具体的编写规则可以参考nosipage rmi 容器的管理
run
创建新的容器，且会使用run指定启动规则，例如端口的映射，volumes文件的指定，以及其他重要参数等，这个命令可以说重要，因为同一个镜像，使用不同参数启动之后，效果是不一样的，对于开发来时，更多的是参与后期的开发，如果不是前期的项目设计，这里了解即可，但是最好的是知道他的只要参数的意义，因为和其他命令有的是通用的，例如-i -t -p等 start stop restart exec
使用此命令可以进入运行中的容器中区，exec -it xxx command attach rm logs cp</description><category domain="https://poorguyorz.github.io/tags/docker/">Docker</category></item><item><title>C++ Primer Plus</title><link>https://poorguyorz.github.io/posts/languange/cpp/</link><guid isPermaLink="true">https://poorguyorz.github.io/posts/languange/cpp/</guid><pubDate>Sun, 20 Feb 2022 20:54:01 +0800</pubDate><author>a_designer@qq.com (Wakaka)</author><copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright><description>编译器 把高级语言编译成可执行语言工具，分为前端后后端，前端值得是高级语言的解析，后端是指翻译解析之后的结果为机器语言
多文件 ** 连接 多文件编译可以有两种方式，一是直接编译为一个可以执行文件，二是按模块或者按文件编译为库，然后连接到执行文件
连接方式有两种， 一是静态连接，把所有的库文件打包到最后的生成文件中，优点是不需要额外的依赖外部环境，独立性强，缺点是文件体积大 二是动态链接，为了解决静态链接的缺点，执行文件在执行到库相关的代码的时候才加载库，有一点需要注意的是，程序运行的时候，在使用到动态库的时候才映射动态库到内存空间中。原理是编译待援在编译的时候，会更具声明生成函数的调用逻辑，但是只是一个地址跳转语句，所以，只要不调用，就不会有问题，当调用到了。才会加载库然后映射库的地址，这个完整的过程称为重定向。 动态连接 C语言编程透视 声明 声明是为了在编译的时候编译器能进行完整的上下文编译。他需要更具声明来确定编译信息，否则编译器无法确定编译中的语句信息，声明可以辅助完成这个情况， 所以理论上编译的时候是可以不需要实现的，可以在其他编译单元中实现声明的函数，其声明的文件可以不引用头文件，即两个编译单元完全可以无任何联系，除了声明之外，在连接的时候，连接器会根据编译出来的信息去确定函数调用情况，这里有一个问题，按上述的描述，是一个声明对应一个实现，如果有一个声明对应多个实现呢 == ： 会有覆盖问题，如果多个动态链接库都有同一个声明的实现，则连接的时候连接第一个，后面的则忽略，这也提醒我们，在大型项目中，避免同名全局函数或者变量，使用namespace或者static限制作用域，
1 2 g++ -o tt ../main.cpp -ldl ./libhellolib.so ./libhellolib1.so LD_LIBRARY_PATH=$PWD ./tt 头文件，避免公用代码的重复，预处理时展开头文件，需要使用#pragma once避免重复引用，头文件只是简单的文件替换，理论上的可以替换任何文本。 cmake * 子模块，使用add_subdirectory引入 * 第三方库 * 只是头文件，直接指定头文件目录编译即可 * 使用子模块 * 使用为连接库 * 使用git模块</description><category domain="https://poorguyorz.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</category><category domain="https://poorguyorz.github.io/tags/c-/">C++</category></item><item><title>Hello World</title><link>https://poorguyorz.github.io/posts/others/hello-world/</link><guid isPermaLink="true">https://poorguyorz.github.io/posts/others/hello-world/</guid><pubDate>Mon, 07 Feb 2022 03:54:01 +0800</pubDate><author>a_designer@qq.com (Wakaka)</author><copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright><description>Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.
Quick Start Create a new post 1 $ hexo new &amp;#34;My New Post&amp;#34; More info: Writing</description><category domain="https://poorguyorz.github.io/tags/test_tag/">test_tag</category><category domain="https://poorguyorz.github.io/tags/asd/">asd</category></item></channel></rss>