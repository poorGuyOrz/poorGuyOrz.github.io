<!doctype html><html lang=zh-cn><head prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article#"><meta charset=utf-8><meta name=generator content="Hugo 0.92.1"><meta name=theme-color content="#16171d"><meta name=color-scheme content="light dark"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=format-detection content="telephone=no, date=no, address=no, email=no"><meta http-equiv=cache-control content="no-transform"><meta http-equiv=cache-control content="no-siteapp"><title>面试 | Wakak</title><link rel=stylesheet href=/css/meme.min.1856ddcc2a28b1f6b5ed4deca62655bf630fee9081ff852bb1d25a4134fccf1a.css><script src=/js/meme.min.4c8facfc8134c52bd7bf6bbfa3a7e68b06b47ae04968222e28e7831f5b1a7592.js></script>
<link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=stylesheet href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400;0,500;0,700;1,400;1,700&family=Noto+Serif+SC:wght@400;500;700&family=Source+Code+Pro:ital,wght@0,400;0,700;1,400;1,700&display=swap" media=print onload="this.media='all'"><noscript><link rel=stylesheet href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400;0,500;0,700;1,400;1,700&family=Noto+Serif+SC:wght@400;500;700&family=Source+Code+Pro:ital,wght@0,400;0,700;1,400;1,700&display=swap"></noscript><meta name=author content="Wakaka"><meta name=description content="面试 只是一个技术汇总
   C++基础 [2 days] [课程- https://github.com/parallel101/course.git]
 内存   内存结构 [https://segmentfault.com/a/1190000039348996]
   c++ 编译出来的是可执行文件，是ELF格式的，他本来就有一些格式上的划分，C++在他的基础上进行了更细的划分，分为五个部分，从高地址到底地址依次为：     1. 内核虚拟内存   进程的虚拟印象   2. 栈   程序自动控制，具体为程序的函数调用，保存局部变量，有大小，可以使用ulimit -s 查看，也可以自行设置，但是建议系统默认即可   * 函数调用机制   调用的时候是一个一个的栈帧，函数参数会在调用者的栈帧中开辟空间，从右到左，所以函数列表的默认值必须从右到左的初始化， 可能和这个有关系，然后被调用者构造栈帧，依次执行     3."><link rel="shortcut icon" href=/favicon.ico type=image/x-icon><link rel=mask-icon href=/icons/safari-pinned-tab.svg color=#2a6df4><link rel=apple-touch-icon sizes=180x180 href=/icons/apple-touch-icon.png><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-title content="Wakak"><meta name=apple-mobile-web-app-status-bar-style content="black"><meta name=mobile-web-app-capable content="yes"><meta name=application-name content="Wakak"><meta name=msapplication-starturl content="../../../"><meta name=msapplication-TileColor content="#fff"><meta name=msapplication-TileImage content="../../../icons/mstile-150x150.png"><link rel=manifest href=/manifest.json><link rel=canonical href=https://poorguyorz.github.io/posts/bigdata/log/><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","datePublished":"2022-03-24T20:26:11+08:00","dateModified":"2022-05-18T00:19:12+08:00","url":"https://poorguyorz.github.io/posts/bigdata/log/","headline":"面试","description":"面试 只是一个技术汇总\n   C++基础 [2 days] [课程- https://github.com/parallel101/course.git]\n 内存   内存结构 [https://segmentfault.com/a/1190000039348996]\n   c++ 编译出来的是可执行文件，是ELF格式的，他本来就有一些格式上的划分，C++在他的基础上进行了更细的划分，分为五个部分，从高地址到底地址依次为：     1. 内核虚拟内存   进程的虚拟印象   2. 栈   程序自动控制，具体为程序的函数调用，保存局部变量，有大小，可以使用ulimit -s 查看，也可以自行设置，但是建议系统默认即可   * 函数调用机制   调用的时候是一个一个的栈帧，函数参数会在调用者的栈帧中开辟空间，从右到左，所以函数列表的默认值必须从右到左的初始化， 可能和这个有关系，然后被调用者构造栈帧，依次执行     3.","inLanguage":"zh-CN","articleSection":"posts","wordCount":584,"image":"https://poorguyorz.github.io/icons/apple-touch-icon.png","author":{"@type":"Person","description":"Viva La Vida","email":"a_designer@qq.com","image":"https://poorguyorz.github.io/icons/apple-touch-icon.png","url":"https://poorguyorz.github.io/","name":"Wakaka"},"license":"[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)","publisher":{"@type":"Organization","name":"Wakak","logo":{"@type":"ImageObject","url":"https://poorguyorz.github.io/icons/apple-touch-icon.png"},"url":"https://poorguyorz.github.io/"},"mainEntityOfPage":{"@type":"WebSite","@id":"https://poorguyorz.github.io/"}}</script><meta property="og:title" content="面试"><meta property="og:description" content="面试 只是一个技术汇总
   C++基础 [2 days] [课程- https://github.com/parallel101/course.git]
 内存   内存结构 [https://segmentfault.com/a/1190000039348996]
   c++ 编译出来的是可执行文件，是ELF格式的，他本来就有一些格式上的划分，C++在他的基础上进行了更细的划分，分为五个部分，从高地址到底地址依次为：     1. 内核虚拟内存   进程的虚拟印象   2. 栈   程序自动控制，具体为程序的函数调用，保存局部变量，有大小，可以使用ulimit -s 查看，也可以自行设置，但是建议系统默认即可   * 函数调用机制   调用的时候是一个一个的栈帧，函数参数会在调用者的栈帧中开辟空间，从右到左，所以函数列表的默认值必须从右到左的初始化， 可能和这个有关系，然后被调用者构造栈帧，依次执行     3."><meta property="og:url" content="https://poorguyorz.github.io/posts/bigdata/log/"><meta property="og:site_name" content="Wakak"><meta property="og:locale" content="zh"><meta property="og:image" content="https://poorguyorz.github.io/icons/apple-touch-icon.png"><meta property="og:type" content="article"><meta property="article:published_time" content="2022-03-24T20:26:11+08:00"><meta property="article:modified_time" content="2022-05-18T00:19:12+08:00"><meta property="article:section" content="posts"></head><body><div class=container><header class=header><div class=header-wrapper><div class="header-inner single"><div class=site-brand><a href=/ class=brand>Wakak</a></div><nav class=nav><ul class=menu id=menu><li class="menu-item active"><a href=/posts/><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon archive"><path d="M32 448c0 17.7 14.3 32 32 32h384c17.7.0 32-14.3 32-32V160H32v288zm160-212c0-6.6 5.4-12 12-12h104c6.6.0 12 5.4 12 12v8c0 6.6-5.4 12-12 12H204c-6.6.0-12-5.4-12-12v-8zM480 32H32C14.3 32 0 46.3.0 64v48c0 8.8 7.2 16 16 16h480c8.8.0 16-7.2 16-16V64c0-17.7-14.3-32-32-32z"/></svg><span class=menu-item-name>Posts</span></a></li><li class=menu-item><a href=/tags/><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512" class="icon tags"><path d="M497.941 225.941 286.059 14.059A48 48 0 00252.118.0H48C21.49.0.0 21.49.0 48v204.118a48 48 0 0014.059 33.941l211.882 211.882c18.744 18.745 49.136 18.746 67.882.0l204.118-204.118c18.745-18.745 18.745-49.137.0-67.882zM112 160c-26.51.0-48-21.49-48-48s21.49-48 48-48 48 21.49 48 48-21.49 48-48 48zm513.941 133.823L421.823 497.941c-18.745 18.745-49.137 18.745-67.882.0l-.36-.36L527.64 323.522c16.999-16.999 26.36-39.6 26.36-63.64s-9.362-46.641-26.36-63.64L331.397.0h48.721a48 48 0 0133.941 14.059l211.882 211.882c18.745 18.745 18.745 49.137.0 67.882z"/></svg><span class=menu-item-name>Tags</span></a></li><li class=menu-item><a id=theme-switcher href=#><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon theme-icon-light"><path d="M193.2 104.5 242 7a18 18 0 0128 0l48.8 97.5L422.2 70A18 18 0 01442 89.8l-34.5 103.4L505 242a18 18 0 010 28l-97.5 48.8L442 422.2A18 18 0 01422.2 442l-103.4-34.5L270 505a18 18 0 01-28 0l-48.8-97.5L89.8 442A18 18 0 0170 422.2l34.5-103.4-97.5-48.8a18 18 0 010-28l97.5-48.8L70 89.8A18 18 0 0189.8 70zM256 128a128 128 0 10.01.0M256 160a96 96 0 10.01.0"/></svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon theme-icon-dark"><path d="M27 412A256 256 0 10181 5a11.5 11.5.0 00-5 20A201.5 201.5.0 0142 399a11.5 11.5.0 00-15 13"/></svg></a></li></ul></nav></div></div><input type=checkbox id=nav-toggle aria-hidden=true>
<label for=nav-toggle class=nav-toggle></label>
<label for=nav-toggle class=nav-curtain></label></header><main class="main single" id=main><div class=main-inner><article class="content post h-entry" data-align=justify data-type=posts><h1 class="post-title p-name">面试</h1><div class=post-meta><time datetime=2022-03-24T20:26:11+08:00 class="post-meta-item published dt-published"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" class="icon post-meta-icon"><path d="M148 288h-40c-6.6.0-12-5.4-12-12v-40c0-6.6 5.4-12 12-12h40c6.6.0 12 5.4 12 12v40c0 6.6-5.4 12-12 12zm108-12v-40c0-6.6-5.4-12-12-12h-40c-6.6.0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6.0 12-5.4 12-12zm96 0v-40c0-6.6-5.4-12-12-12h-40c-6.6.0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6.0 12-5.4 12-12zm-96 96v-40c0-6.6-5.4-12-12-12h-40c-6.6.0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6.0 12-5.4 12-12zm-96 0v-40c0-6.6-5.4-12-12-12h-40c-6.6.0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6.0 12-5.4 12-12zm192 0v-40c0-6.6-5.4-12-12-12h-40c-6.6.0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h40c6.6.0 12-5.4 12-12zm96-260v352c0 26.5-21.5 48-48 48H48c-26.5.0-48-21.5-48-48V112c0-26.5 21.5-48 48-48h48V12c0-6.6 5.4-12 12-12h40c6.6.0 12 5.4 12 12v52h128V12c0-6.6 5.4-12 12-12h40c6.6.0 12 5.4 12 12v52h48c26.5.0 48 21.5 48 48zm-48 346V160H48v298c0 3.3 2.7 6 6 6h340c3.3.0 6-2.7 6-6z"/></svg>&nbsp;2022.3.24</time>
<time datetime=2022-05-18T00:19:12+08:00 class="post-meta-item modified dt-updated"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" class="icon post-meta-icon"><path d="M4e2 64h-48V12c0-6.627-5.373-12-12-12h-40c-6.627.0-12 5.373-12 12v52H160V12c0-6.627-5.373-12-12-12h-40c-6.627.0-12 5.373-12 12v52H48C21.49 64 0 85.49.0 112v352c0 26.51 21.49 48 48 48h352c26.51.0 48-21.49 48-48V112c0-26.51-21.49-48-48-48zm-6 4e2H54a6 6 0 01-6-6V160h352v298a6 6 0 01-6 6zm-52.849-200.65L198.842 404.519c-4.705 4.667-12.303 4.637-16.971-.068l-75.091-75.699c-4.667-4.705-4.637-12.303.068-16.971l22.719-22.536c4.705-4.667 12.303-4.637 16.97.069l44.104 44.461 111.072-110.181c4.705-4.667 12.303-4.637 16.971.068l22.536 22.718c4.667 4.705 4.636 12.303-.069 16.97z"/></svg>&nbsp;2022.5.18</time>
<span class="post-meta-item wordcount"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon post-meta-icon"><path d="M497.9 142.1l-46.1 46.1c-4.7 4.7-12.3 4.7-17 0l-111-111c-4.7-4.7-4.7-12.3.0-17l46.1-46.1c18.7-18.7 49.1-18.7 67.9.0l60.1 60.1c18.8 18.7 18.8 49.1.0 67.9zM284.2 99.8 21.6 362.4.4 483.9c-2.9 16.4 11.4 30.6 27.8 27.8l121.5-21.3 262.6-262.6c4.7-4.7 4.7-12.3.0-17l-111-111c-4.8-4.7-12.4-4.7-17.1.0zM124.1 339.9c-5.5-5.5-5.5-14.3.0-19.8l154-154c5.5-5.5 14.3-5.5 19.8.0s5.5 14.3.0 19.8l-154 154c-5.5 5.5-14.3 5.5-19.8.0zM88 424h48v36.3l-64.5 11.3-31.1-31.1L51.7 376H88v48z"/></svg>&nbsp;584</span>
<span class="post-meta-item reading-time"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon post-meta-icon"><path d="M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zm0 448c-110.5.0-2e2-89.5-2e2-2e2S145.5 56 256 56s2e2 89.5 2e2 2e2-89.5 2e2-2e2 2e2zm61.8-104.4-84.9-61.7c-3.1-2.3-4.9-5.9-4.9-9.7V116c0-6.6 5.4-12 12-12h32c6.6.0 12 5.4 12 12v141.7l66.8 48.6c5.4 3.9 6.5 11.4 2.6 16.8L334.6 349c-3.9 5.3-11.4 6.5-16.8 2.6z"/></svg>&nbsp;3&nbsp;分钟</span></div><div class="post-body e-content"><h1 id=面试>面试</h1><p style=text-indent:0><span class=drop-cap>只</span>是一个技术汇总</p><hr><ul><li><p>C++基础 [2 days] [课程- https://github.com/parallel101/course.git]</p><ul><li>内存<ul><li><p>内存结构 [https://segmentfault.com/a/1190000039348996]</p><div class=table-container><table><thead><tr><th>c++ 编译出来的是可执行文件，是ELF格式的，他本来就有一些格式上的划分，C++在他的基础上进行了更细的划分，分为五个部分，从高地址到底地址依次为：</th></tr></thead><tbody><tr><td>1. 内核虚拟内存</td></tr><tr><td>进程的虚拟印象</td></tr><tr><td>2. 栈</td></tr><tr><td>程序自动控制，具体为程序的函数调用，保存局部变量，有大小，可以使用ulimit -s 查看，也可以自行设置，但是建议系统默认即可</td></tr><tr><td>* 函数调用机制</td></tr><tr><td>调用的时候是一个一个的栈帧，函数参数会在调用者的栈帧中开辟空间，从右到左，所以函数列表的默认值必须从右到左的初始化， 可能和这个有关系，然后被调用者构造栈帧，依次执行</td></tr></tbody></table></div><pre><code>  3. 共享库的内存印象
  3. 堆  
      空间有程序员自行维护，向上增长(TIPS: 由于C的历史原因，C++的内存结构还是说堆区，但是在区别new/malloc 和delete/free 的时候，他们的差别之一可能会在内存上有点区别
      C的malloc/free可能会说是在堆上分配空间，但是对于C++可能会说的是在自由存储区上分配，自由存储区和堆是不同的概念，堆是操作系统上的概念，但是自由存储区是一个抽象概念
      一般new可以是在堆上分配空间，但是可能存在在其他情况，例如在栈上使用new，所以他们不是一个概念，面试的时候说到这里，可以装逼😎)
  4. 可写/全局区
      对应elf中data段和bss段，data段保存的是已初始化的全局变量或者静态变量，bss保存的是未初始化的数据
  5. 只读区
      text段，保存编译之后的指令，不可变
  6. 常量区
      保存全局变量，不可变，rodata段，记得使用其他手段去尝试修改常量的时候会报错。  
      TIPS: const修饰的参数不一定是常量，例如他修饰一个函数的参数的时候，参数还是只是在栈中，只是约定不能修改。
  7. 未使用
</code></pre></li><li><p>内存管理</p><ul><li>new
C++有对象的概念，所以他的new大意上是malloc的封装，先申请对象的内存空间，然后调用对象的构造函数构造对象，用在数组上是，先申请所有的空间，然后再依次调用构造函数</li><li>delete
删除对象，先调用析构函数，然后再释放空间<ul><li>对象数组
如果调用的是delete[]，如果是基础类型，则删除的时候使用delete和delete[] 都没有区别，因为空间连续的，有额外的空间记录内存的大小，直接使用delete的时候可以直接伤处 如果是自定义对象，如果有指针这类的属性，则必须调用delete[]，
否则他只会调用第一个对象的析构函数，可能会导致内存泄露</li></ul></li></ul><div class=table-container><table><thead><tr><th>&ndash; new malloc 的区别</th></tr></thead><tbody><tr><td>1. 空间分配的概念上</td></tr><tr><td>一个是堆区，一个是自由存储区</td></tr><tr><td>2. 使用上</td></tr><tr><td>new会调用构造函数，且new会自行计算对象所需的空间大小，malloc需要自行指定</td></tr><tr><td>3. 概念上</td></tr><tr><td>malloc是标准函数，而new是关键字</td></tr></tbody></table></div></li><li><p>虚表</p><ul><li><a href=https://www.zhihu.com/question/389546003/answer/1194780618 target=_blank rel=noopener>实现</a><br>虚表是多态的一种实现，但是不是C++的规定，而是编译器的自行的实现方法，在函数中只要声明虚函数，则对象中就会有额外的空间用于保存虚表，他是一个指针，指向虚表，所以对于有虚表的对象
sizeof的时候会计算这个指针的大小，指针指向虚表的第三个槽位，gdb查看地址的时候会显示+16的字样，因为这是实际的函数指针的开始位置，前两个槽位一个一般是0，拎一个一般是typeinfo的地址，
虚表和他的附属信息在内存中都是一起的，其实从根本原理上来说，他只是做了一层转换，实际上函数的调用最终的实现都是面向过程的函数的调用，函数才是C++ 的核心，<br>而且虚表由于调用的时候需要寻址，所以会导致性能问题，主要是由于需要进行地址跳转，跳转会有性能损耗，且由于局部性原理，指令会有预读机制，跳转之后可能导致cache miss，导致流水线失效<ul><li>验证方法<br>编译的时候使用参数-fdump-lang-class，gdb调试的时候使用set print asm-demangle on，然后x/b打印地址</li></ul></li><li>虚继承
同样使用到虚表，父类只有一份副本</li></ul></li><li><p>智能指针</p></li><li><p>STL<br>两级情况，如果对象小于128K，则使用内存池，如果大于128K，则向系统申请空间，内存池使用链表维护</p></li><li><p>构造函数</p><ol><li>构造函数 （<code>A();</code>）</li><li>拷贝构造函数（<code>A(const A&);</code>）</li><li>析构函数（<code>~A();</code>）</li><li>重载赋值运算函数（<code>A& operator = (const A&);</code>）</li><li>重载取址运算函数（<code>A* operator & ();</code>）</li><li>重载取址const运算函数（<code>const A* operator & () const;</code>）</li><li>移动构造函数（<code>A(A&&);</code>）</li><li>重载移动复制函数（<code>A& operator = (const A&&);</code>）</li></ol></li><li><p>模板
编译期按照实际的类型进行代码的动态扩展，遇到使用的新的模板类型的时候，就编译出对应的类型的代码。类似与在编译期对代码进行重载。</p><ul><li>模板参数除了类型，还支持整形，但是必须是常量</li><li>模板使用的时候，会自动进行类型推导。无序声明参数</li><li>模板是惰性编译的，只有使用到了才会编译。所以模板的实现最好写在一起</li><li>lambda也支持模板</li></ul></li><li><p>多线程内存模型</p><ul><li>线程
线程运行时有单独的运行栈，如果是局部变量，则无数竞争的情况，如果有数据竞争的情况，则需要了解
0. 缓存架构
多线程下数据竞争的问题几乎都是缓存导致，缓存当前普遍的模型是三层，L1L2单独对应cpu，L3对应一个核上的所有CPU，如果多线程的情况下，可能会有缓存不一致的情况，导致结果不符合预期，简单的例子是多线程的数据累加，解决方法是使用锁或者信号量或者把变量设置未原子类型。<ol><li>指令重排
有几种情况，一是编译器优化，二是cpu优化，三是cpu的乱序执行，它可以在一个始终周期内执行多条指令，所以可能看起来是无序的</li><li>内存顺序</li><li>volatile
在使用某个变量的时候，会直接从变量地址取数据，但是不保证更改的时候的原子性，所以上面0中的场景不可以使用volatile解决。本意是禁止变量的优化</li></ol></li></ul></li></ul></li><li>函数
C++支持自定义对象，可以使用自己定义的函数，最终的是实现是把函数编译成为普通函数，只是函数的参数列表默认的会带上一个对象的指针，最底层实际上还是类似于C的面向过程。</li><li>语法</li><li>编译</li><li>STL<ul><li>容器
简单的理解就是具体的数据结构的实现，然后提供了具体的实现方法，对于通用的函数，则单独使用算法实现，<ul><li>容器分类<ul><li>序列式<ul><li>array
数组，空间上连续，预分配空间。不可自动扩容，简单的数组的封装</li><li>vector
解决array的问题，自动扩容，扩容时需要重新分配空间，然后移动数据到新空间，这个操作可能会导致迭代器失效，扩容因子不确定，有的是1.5倍增长，有的是2，扩容有性能问题，所以使用的时候明确场景，然后预先设置容量，避免扩容操作</li><li>deque
双向队列，是用多段数组和一个控制中心实现的</li><li>stack/queue
对列和栈，使用deque实现</li><li>list
双向链表</li><li>单向链表</li></ul></li><li>关联式<ul><li>map
底层有一个隐藏的红黑树容器，存储键值对，按键排序</li><li>set
同map，但是是键值和一的</li></ul></li></ul></li><li>迭代器
迭代器在删除数据的时候可能会导致失效问题，对于内存空间上连续的容器，由于删除之后需要其他的数据填补空洞，所以迭代器会移动到下一个位置，对于关联式容器，当前元素迭代器失效，需要手动记录下一个元素位置</li><li>容器使用</li></ul></li><li>算法<ul><li>STL中的一大项，由于是为了配合容器使用，所以几乎所有的算法都需要使用迭代器作为参数，然后大部分算法可以自行提供计算规则</li></ul></li></ul></li><li>特性<ul><li>11新特性</li></ul></li><li>GDB<ul><li>调试技巧</li></ul></li></ul></li><li><p>数据结构与算法 [3 天整理知识列表，长期进行]</p><ul><li>树<ul><li>二叉树</li><li>堆</li><li>234树</li><li>红黑树</li><li>B树</li><li>B+树</li></ul></li><li>hash</li><li>线性表<ul><li>数组</li><li>链表</li><li>队列</li><li>栈</li></ul></li><li>图<ul><li>存储方式</li></ul></li><li>跳表</li><li>LRU</li><li>排序</li><li>dfs</li><li>bfs</li><li>二分</li><li>&mldr;</li></ul></li><li><p>数据库 [3 天整理知识列表]</p><ul><li><p>编译</p><ul><li><p>编译原理</p></li><li><p>SQL编译过程
词法分析 语法分析之后得到ast，然后使用元数据堆ast进行类型绑定，同时进行常规检查，类似语义分析
词法分析和语法分析的大致过程为先堆语句进行分词，生成token，常见的工具为yacc，然后使用语义分析工具接收tioken，进行语义检查且生成语法树，语法分析有几种分析方法，一是自底向上，二是自顶向下，</p><ul><li>文法<ul><li>LL(k)文法，第一个L指的是left to right，第二个L指的是最左推导</li><li>LR文法，R指的是最右推导，也成为最左规约</li></ul></li><li>自顶向下
从token序列的最左端开始，读入token，然后匹配已有的规则，如果匹配到最后正在匹配的规则和输入不匹配，则进行回溯，匹配下一个可以匹配的规则，如果没有可以匹配的，则失败，特点是可能需要进行大量的回溯</li><li>自底向上
从输入的token开始，依次入栈，称为移进操作，然后如果栈中的数据可以匹配某规则，则使用规则替换，称为规约，反复进行此动作，直到生成一个语法树，每一次规约都会产生一个节点，此方法使用比较广泛，因为没有回溯操作，</li></ul><p>tip： SQL说到底也是一门语言，在编译阶段和其他的编译器结构类似，只是是可定制，大致分为前端和后端，对于前端，如果是老的项目，则只需要能添砖加瓦即可，</p></li></ul></li><li><p>优化</p><ul><li>优化规则<ul><li>RBO
基于规则的优化，基于经验主义，使用之前积累的优化的可以无条件优化的规则，实质上是关系代数的等价变换，变换的目的是尽可能的在下层把无用的数据消除掉，减少不必要的数据运算<ul><li>关系代数的优化
一些明显的可以减少运算数据的优化方法，例如谓词下推，先投影等</li><li>子查询的优化
子查询会出现的位置是不一定的，在语句中，语义上他可以作为一张表来看，子查询分为关联子查询和非关联子查询<ol><li>关联子查询
子查询依赖外部属性</li><li>非关联子查询
子查询独立存在</li></ol><ul><li>优化方法
最常用的方法是通过子查询展开消除子查询，把子查询变换为连接操作，然后进行连接操作的优化，如果没有聚合操作，大部分的语句可以优化</li></ul></li><li>谓词重写
对于一些谓词，使用其他等价规则重写，目的是为了更好的进行优化，例如like重写为大于and小于，in重写添加查询范围，any和all添加查询范围等。</li><li>条件化简
目的是简化查询条件，便于优化，必要的时候需要重写表达式或者添加一些表达式</li><li>视图重写</li><li>连接消除<ul><li>外连接消除
原因是外连接的连接顺序是不可变的，所以尽可能的把外连接转换为内连接，可转换的条件是可空侧没有null值输出，则可以直接转换为内连接，例如可空侧使用is not null 限制，</li><li>内连接</li></ul></li><li>join<ul><li>left join</li><li>right join</li><li></li></ul></li><li></li></ul></li><li>CBO
基于代价的优化，由于一个逻辑算子的物理实现可能有多个物理算子，所以需要在实际的使用场景中选择合适的物理算子，且在多个表达式的情况下，每个逻辑算子的最有的执行计划可能得到的结果也不是最优的，所以一般需要考虑数据统计信息，以及环境的io情况，内存大小，是否是分布式环境等，然后使用这些信息计算出cost最小的执行计划，cost只是一个变量，目的是为了对计划可以与一个具体的衡量指标</li></ul></li><li>优化框架 <a href=https://zhuanlan.zhihu.com/p/73545345 target=_blank rel=noopener>https://zhuanlan.zhihu.com/p/73545345</a><ul><li>遗传算法
pg默认在表数量大于13的时候使用遗传算法，可能得到的不是最优的执行计划，他是通过组合然后按计划代价排序，然后随机变异，淘汰最差解得到最后的执行计划的，不是全局最优解，但是搜索空间小，</li><li>自底向上
自底向上的动态规划算法，可以得到全局最优解，但是搜索空间巨大，PG只有在表数量小于13的时候使用此方法。<ol><li>初始化叶子节点，每个节点取得当前最优执行计划</li><li>组合每个叶子节点的得到第二层，保留每个组合</li><li>使用第一层和第二层组合得到第三层</li><li>重复类似的方式得到最优解，在计算N层的时候，具体选取那一层暂时没有结论</li></ol><ul><li>对于是否是order的，需要单独额外记录，否则底层选择的计划上层无法得知是否为最优的。</li></ul></li><li>system R
也是一种自底向上，但是只保留最优和次优解，用于上层的执行计划的生成，最后的执行计划可能不是全局最优</li><li>Volcano [The Volcano Optimizer Generator: Extensibility and Efficient Search http://www.cse.iitb.ac.in/infolab/Data/Courses/CS632/Papers/Volcano-graefe.pdf]</li><li>Cascades<ul><li>expression
有逻辑表达式和物理表达式，他们在group中是等价的</li><li>group
等价表达式的集合，等价的意思是他们的输入和输出是一样的</li><li>rule
对group的变换规则，有物理算子的实现规则，有逻辑算子的转换规则，目的是为了扩大搜索空间</li><li>memo
搜岁空间，存放group</li></ul><ol><li>首先初始化搜索空间，即初始化所有group</li><li>从根节点开始，然后使用rule扩展搜索空间</li><li>使用dfs搜索</li><li>可以设置代价阈值，搜索时间限制等，使优化过程提前终止</li><li>可以自行指定执行计划</li></ol></li><li>启发式</li></ul></li></ul></li><li><p>执行</p><ul><li><p>算子实现</p><ul><li>join<ul><li>merge join<br>如果表是有序的，则优先选择merge join，否则数据无序且强行走merge join的话，会导致数据进行排序，可能会有极大的性能损耗</li><li>hash join<ol><li>小表作为驱动表，构造hash表，然后使用此hash表对另一个表进行hash，如果存在，则匹配成功，此步称为probe|探测。代价主要是两个表的full scan和hash表的内存以及建立hash 的时间</li><li>如果都是大表且内存无法方法构建之后的hash表，有几种方法<ol><li>先对原表进行分区，然后再对各个分区单独进行hash匹配，相比之前，代价是被驱动表的full scan*n 和驱动表的scan和内存损耗</li><li>同时对两表使用相同的分区方式进行分区，然后在各自的分区内进行hash，相比上面的方法，这里可以使用多线程或者多进程进行处理</li></ol></li></ol></li><li>nest loop join<br>小表驱动大表，小表读取一行数据之后，使用此行数据到被驱动表进行匹配，所以如果被驱动表的对应的键只是普通的键的话，可能会全表扫面，所以需要被驱动表有index或者键是主键等可以直接按照key定位数据的表，代价为n*m + n</li><li>如过是分布式的环境，则可能有数据的跨界点的传输的情况，有一张IO时间的表格表示，网络io的时间是非常长的，所以需要尽可能的保证数据在当前节点进行计算。如果必须传输数据，则<ol><li>小表进行广播，各节点使用小表join</li><li>常规的join运算<br>但是如果在表分区的是否，可以保证join的数据在同于一个分区上是相同的分区方式，则可以直接本节点join然后汇总数据，clickhouse的分区可以实现这种需求，分区对其</li></ol></li></ul></li><li>sort<br>排序，数据是按块操作的，可以使用merge sort，也可以通过在内存中构造一个有序的数据结构然后输出，如果内存放不下数据，则可以把数据临时放在内存外，另外，由于是按块操作的，所以可以在块中存放当前块的min max，可以使用此信息加速排序等。</li><li>窗口函数<br><a href=https://zhuanlan.zhihu.com/p/80051518 target=_blank rel=noopener>https://zhuanlan.zhihu.com/p/80051518</a></li><li>常规函数</li></ul></li><li><p>执行框架</p><ul><li>火山模型/Volcano<br>每个算子实现next，open,close方法，tuple-at-a-time类似于迭代器，用于向上层节点向下层节点拉取数据，早期cpu和mem的新能还在增长所以当时这种技术几乎是首选，运行是时间耗时主要为io，且由于大量next的调用，都会导致流水线被破坏。</li></ul></li><li><p>向量化<br>简单理解就是每个算子批量处理数据，早期的Volcano 模型的单行处理，会导致缓存，指令调度，分支预测错误等导致性能下降，在TP的场景中最为明显，因为AP是行存的，所以为了解决这些问题， MonetDB/X100: Hyper-Pipelining Query Execution提出vector-at-a-time执行模式，大致方向为：</p><ul><li>保持Volcano模型大致结构基本不变，但是原来的tuple保存一行的操作使用vector替代，保存列，数据大小尽量可以都放在缓存中<br>所以他更多的适用于列存，行存也可以使用类似的方法来加速，但是可能效果没有列存优秀</li><li>使用向量化原语计算<br>上下文无关的计算逻辑，专门计算vector的数据</li><li>使用延迟物化技术减少内存的读写开销<br>记录vector中的数据变动，尽可能晚的变动内存中的数据</li><li>使用代码生成来避免类型转换代码的大量代码分支</li><li>CPU在计算同类型数据的时候更容易使用simd优化<br>TIPS:<ol><li>分支预测，局部性原理，会预加载多条指令，在遇到代码跳转的时候，清空当前流水线，加载其他流水线，导致性能问题，典型的场景是排序一组有序数据和无序数据之间的差距明显</li><li>cache miss，使用的数据不在缓存中，需要去内存中读取，记得之前有测试AOS，SOA之间的差距可以达到四五倍</li></ol></li></ul></li><li><p>codegen<br>把执行计划中不需要物化的算子实现为一个表达式，而不是以task的方式调度，具体实现为：</p><ol><li>对于算子树，使用深度优先遍历，生成一段代码</li><li>对于Volcano模型来说，就是task算子的调用层级是现在一段代码逻辑中</li><li>数据流动的时候可以直接存储在寄存器中，而不需要物化操作</li><li>对于block算子，则必须物化</li><li>由底层节点开始，向上推送数据</li><li>适合计算场景，可以优化代码，提升寄存器的利用率</li></ol><p>所以对于一个执行计划，codegen的就是把他实现为一个整体，而不是Volcano类似的面对对象的实现</p></li></ul><p>[Everything You Always Wanted to Know About Compiled and Vectorized Queries But Were Afraid to Ask https://www.bilibili.com/video/av50329586/]
案例：
tidb使用的是向量化，即使它使用的是行存，他会在数据读取出来之后转换数据模式为vector，以便于使用向量化</p></li><li><p>存储</p><ul><li>存储格式<ul><li>行存</li><li>列存</li></ul></li><li>存储的数据结构 【LSM <a href=https://www.yuque.com/earayu/kkdi0n/gqibsf#pSa3E target=_blank rel=noopener>https://www.yuque.com/earayu/kkdi0n/gqibsf#pSa3E</a>】<br>LSM<br>* 起源<br>- B+tree的异地更新，定期合并，垃圾回收，顺序写，最先由PG实现，但是由于实现复杂，所以后续的LSM重新设计了数据结构<br>* 数据分层<br>使用sstable保存数据，在内存中是memetable，在磁盘中是sstable，磁盘中sstable只是写，达到一定大小的时候和下层进行合并，典型的实现是leveldb<br>* 写<br>保证数据安全，先写wal<br>写内存中的memtable，当数据满之后。固化memtable<br>memtable落盘，落盘成功之后释放之前的WAL<br>如果此时磁盘中顶层的数据达到限定的阈值，则挑选一个sstable向下层compact，直到所有层都满足要求<br>* 读<br>从内存中的memtable读取数据<br>内存中没有则在磁盘中按层次查找<br>sstable可以使用额外的信息加速查找<br>* 问题<br>在写的时候会有多次IO操作，如果后台进行compact的时候，会导致前端的吞吐量，查询的时候会由读放大问题。<br>LSM 优化<br>LSM适用于HDD，当前SSD中随机读写和顺序读写几乎无太大差距<br>B+tree<br>* 起源<br>目的是为了降低从磁盘中查询数据时候的次数<br>* 组织结构<br>按页大小为单位组织节点，逻辑上的树形结构，树的高度与数据的多少有关，节点满的时候进行分裂<br>* 操作<br>读取的时候按页读取，从根节点开始，定位到子页的时候再去读取子叶，直到叶子节点被读取，页的大小是4KB，假设key为8，地址大小为8，则一组key大小为16，则一页可以指向256页，则两层树高的树可以保存1kw的数据，此时磁盘io只有三次<br>写的时候会检测节点时候full，如果full，则需要split，如果当前层满了，则增加树的高度，<br>* 随机读性能高。如果没有额外的设计，则没有读写放大的问题，且易于实现lock，但是由于写的时候可能会导致树的变化，会有性能问题</li><li>事务<ul><li>特性ACID<ul><li><p>A 原子性</p></li><li><p>C 一致性</p></li><li><p>I 隔离性</p><ul><li>隔离级别</li></ul><ul><li>读未提交<ul><li>脏读<ul><li>长时间持有写锁，短时间持有读锁，只能读取别人已经释放锁的数据</li></ul></li></ul></li><li>读已提交<ul><li>不可重复读<ul><li>长时间持有读锁和写锁，保持数据独占</li></ul></li></ul></li><li>快照都</li><li>可重复读<ul><li>幻读</li></ul></li><li>串行化</li><li>写偏序<ul><li>另一个事务修改数据，导致某事物在处理的数据的时候约束条件改变</li></ul></li></ul></li><li><p>D 持久性</p></li></ul></li></ul></li></ul></li><li><p>案例</p><ul><li>leveldb</li><li>pg</li><li>trafodion</li><li>mysql</li></ul></li></ul></li><li><p>linux [2 天整理知识列表 https://www.bookstack.cn/books/webxiaohua-gitbook]</p><ul><li><p>进程，线程
可以通过init创建，也可以使用fork从父进程创建，fork返回值为0，则是子进程，子进程创建的时候使用写拷贝技术，初始化的时候除了pcb之外，其余的内存呢地址和父进程是一起的，只有当子进程需要修改的时候，才会copy修改为到自己的内存中去，</p><ul><li>调度方法
抢占式和非抢占式
时间片
先进先出
短作业优先
长作业优先
最短剩余时间优先等</li><li>通信</li><li>内存结构<ul><li>虚拟内存
为了给进程提供一个连续的内存空间，逻辑上连续，物理上不一定连续，由于进程的使用会申请和释放空间且空间有有限的，所以需要把一些页面置换出去<ol><li>最佳置换
把以后不会使用的页面置换掉，但是无法实现，不能保证那些页面不会使用</li><li>先进先出</li><li>时钟置换</li><li>最近最久未使用
置换最长时间没有使用的页面
局部性原理，时间局部性和空间局部性，在操作各种资源的时候，可以把当前资源附近的资源一起使用，附近可以是空间，也可以是时间</li></ol></li><li>共享内存
所有页面都映射到相同的内存空间，多进程使用的时候存在竞争问题</li><li>内存碎片
内存可能会导致总体空足够，但是无法申请空间的问题，所以需要较为合适的内存分配算法，内存一般使用链表或者其他类似的数据结构维护<ol><li>首次适应
从链表的首段开始找到合适的内存</li><li>最佳适应
从链表的首段开始，找到最合适的空间</li><li>最大适应
查找到最大的内存空间，从他上面分配内存</li><li>临近适应
从当前的使用位置开始，寻找合适的空间</li></ol></li></ul></li><li>进程间通信<ul><li>线程由于公用地址空间，所以线程可以直接通信，进程由于资源隔离，所以需要额外的通信机制<ol><li>匿名管道
存在在父子进程中，因为fork之后的父子进程具有相同的内存印象，所以可以直接使用</li><li>命名管道
有名的管道，知道名字之后任意进程可以直接使用 mkfifo</li><li>消息队列
一个本质时存放在内核中的链表，消息发送和取消的时候遵循先进先出</li><li>共享内存
所有进程都会映射共享内存，所以可以借助它进行通信</li><li>信号量</li></ol></li></ul></li></ul></li><li><p>协程
简单的理解就是函数调用的状态机？他会记录运行时的状态，在多个执行线路之间进行跳转。一种实现思路时使用堆区维护协程运行context，然后在协程调用的时候记录信息即可。出现时间早，C++最早面世的时候时支持协程的，d大致是在1980s左右，因为当时计算机没有线程的实现，而进程并发代价大，所以协程-用户态线程就出现了，</p></li><li><p>IO多路复用
单线程同时检测多io
select
底层使用数组保存fd，默认大小为1024，所以有操作上限，在使用的时候需要把数组从内核拷贝到用户空间
poll
对select 的改进，底层替换为链表，使用的时候，需要遍历链表
epoll
使用回调机制，当io完成之后放入就绪链表，使用预先注册的回调函数通知用户</p></li><li><p>线程
资源使用的基本单位，进程中的线程公用地址空间，生命周期和进程有关，运行时每一个线程都有自己的运行栈</p></li><li><p>同步/异步</p></li><li><p>并发/并行</p></li></ul></li><li><p>分布式 [2 天整理知识列表]</p><ul><li>共识协议<ul><li>raft</li><li>posie</li></ul></li></ul></li><li><p>大数据 [2 天整理知识列表]</p><ul><li>Hadoop</li><li>spark</li><li>hdfs</li><li>hive</li><li>scala</li></ul></li><li><p>项目经历 [1 天整理知识列表] &ndash; 大厂扯皮必备</p><ul><li><p>分区表
range分区，负责index的维护，split分区，同时后期维护整个分区表的dml实现</p><ul><li>index<ul><li>global index
一个分区表对应一个index，在使用的时候，例如index的全表查询等，就会使用GI</li><li>local index
一个分区对应一个index，在查询单个分区的时候，就会使用此index</li></ul></li><li>split
分裂分区，要求可以分裂任意分区，包括混合分区</li><li>dml<ul><li><p>select
分区查询，按照查询条件决定从那个分区查询，有跨分区的情况</p></li><li><p>insert
分区insert，无法限定insert的数据来源的边界，所以需要全表的分区都进行insert</p></li><li><p>update</p></li><li><p>delete</p></li></ul></li></ul></li><li><p>临时表</p></li><li><p>只读表
数据预加载进缓存，然后从缓存读取 [
当前为只读，后期设计为懒同步，即数据访问从
]</p><ul><li>难点
数据存储模型
memtableDB 维护内存中的表，使用的是hash表，key为table name，values为table
- table 维护一个table对象，使用的是array，数据顺序和原表数据顺序一致
- row 行数据
内存使用
使用内置的内存池，便于计算空间使用率
多节点之间的数据同步，数据维护
* 数据预加载的时候堆表加dml和ddl锁，防止期间外部操作数据变动
* 提供数据一致性检测语法
之前设计的时候，只是想简单的比对数据
之后有一个想法，数据存储在hbase中，暂时没有找到hbase有没有所有数据的checksum实现，没有的话自行实现，然后memtable 中也实现一个checksum，比对的时候直接检测checksum即可，可以在每次查询的时候进行比对
* 原表数据变动的时候，由于存储的架构问题，所以可以完整的追踪每个数据的变化，同时计算checksum
多节点数据预加载时候的查询
存在节点重启或者节点添加或者人工运维只读表的情况，此时禁止读取，使用锁，对共享内存加锁，禁止其他任何操作</li><li>性能
聚合语句的直接提升为上百倍</li></ul></li><li><p>大字段优化</p><ul><li>收获最大 &ndash; 假装<ul><li>范围广，所以追踪数据流向，加快了解项目的执行逻辑</li><li>知道了执行引擎执行逻辑 &ndash; 火山模型</li></ul></li></ul></li><li><p>bug fix</p></li></ul></li></ul></div></article><div class=updated-badge-container><span title="Updated @ 2022-05-18 00:19:12 +0800" style=cursor:help><svg xmlns="http://www.w3.org/2000/svg" width="130" height="20" class="updated-badge"><linearGradient id="b" x2="0" y2="100%"><stop offset="0" stop-color="#bbb" stop-opacity=".1"/><stop offset="1" stop-opacity=".1"/></linearGradient><clipPath id="a"><rect width="130" height="20" rx="3" fill="#fff"/></clipPath><g clip-path="url(#a)"><path class="updated-badge-left" d="M0 0h55v20H0z"/><path class="updated-badge-right" d="M55 0h75v20H55z"/><path fill="url(#b)" d="M0 0h130v20H0z"/></g><g fill="#fff" text-anchor="middle" font-size="110"><text x="285" y="150" fill="#010101" fill-opacity=".3" textLength="450" transform="scale(.1)">updated</text><text x="285" y="140" textLength="450" transform="scale(.1)">updated</text><text x="915" y="150" fill="#010101" fill-opacity=".3" textLength="650" transform="scale(.1)">2022-05-18</text><text x="915" y="140" textLength="650" transform="scale(.1)">2022-05-18</text></g></svg></span></div><div class=post-gitinfo><div class=post-gitinfo-left><div class="gitinfo-item commit"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512" class="icon git-icon"><path d="M384 144c0-44.2-35.8-80-80-80s-80 35.8-80 80c0 36.4 24.3 67.1 57.5 76.8-.6 16.1-4.2 28.5-11 36.9-15.4 19.2-49.3 22.4-85.2 25.7-28.2 2.6-57.4 5.4-81.3 16.9v-144c32.5-10.2 56-40.5 56-76.3.0-44.2-35.8-80-80-80S0 35.8.0 80c0 35.8 23.5 66.1 56 76.3v199.3C23.5 365.9.0 396.2.0 432c0 44.2 35.8 80 80 80s80-35.8 80-80c0-34-21.2-63.1-51.2-74.6 3.1-5.2 7.8-9.8 14.9-13.4 16.2-8.2 40.4-10.4 66.1-12.8 42.2-3.9 90-8.4 118.2-43.4 14-17.4 21.1-39.8 21.6-67.9 31.6-10.8 54.4-40.7 54.4-75.9zM80 64c8.8.0 16 7.2 16 16s-7.2 16-16 16-16-7.2-16-16 7.2-16 16-16zm0 384c-8.8.0-16-7.2-16-16s7.2-16 16-16 16 7.2 16 16-7.2 16-16 16zm224-320c8.8.0 16 7.2 16 16s-7.2 16-16 16-16-7.2-16-16 7.2-16 16-16z"/></svg>6edfca6</div><div class="gitinfo-item commit-msg"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 192 512" class="icon msg-icon"><path d="M20 424.229h20V279.771H20c-11.046.0-20-8.954-20-20V212c0-11.046 8.954-20 20-20h112c11.046.0 20 8.954 20 20v212.229h20c11.046.0 20 8.954 20 20V492c0 11.046-8.954 20-20 20H20c-11.046.0-20-8.954-20-20v-47.771c0-11.046 8.954-20 20-20zM96 0C56.235.0 24 32.235 24 72s32.235 72 72 72 72-32.235 72-72S135.764.0 96 0z"/></svg>languange learn: go</div></div></div><ul class=post-nav><li class=post-nav-prev><a href=/posts/readbooks/columbia-optimizer/ rel=prev>&lt; Columbia Optimizer</a></li><li class=post-nav-next><a href=/posts/readbooks/%E7%8E%B0%E4%BB%A3c++%E7%99%BD%E7%9A%AE%E4%B9%A6/ rel=next>现代C++白皮书 ></a></li></ul></div></main><div id=back-to-top class=back-to-top><a href=#><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" class="icon arrow-up"><path d="M34.9 289.5l-22.2-22.2c-9.4-9.4-9.4-24.6.0-33.9L207 39c9.4-9.4 24.6-9.4 33.9.0l194.3 194.3c9.4 9.4 9.4 24.6.0 33.9L413 289.4c-9.5 9.5-25 9.3-34.3-.4L264 168.6V456c0 13.3-10.7 24-24 24h-32c-13.3.0-24-10.7-24-24V168.6L69.2 289.1c-9.3 9.8-24.8 10-34.3.4z"/></svg></a></div><footer id=footer class=footer><div class=footer-inner><div class=site-info>2022–2022&nbsp;<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon footer-icon"><path d="M462.3 62.6C407.5 15.9 326 24.3 275.7 76.2L256 96.5l-19.7-20.3C186.1 24.3 104.5 15.9 49.7 62.6c-62.8 53.6-66.1 149.8-9.9 207.9l193.5 199.8c12.5 12.9 32.8 12.9 45.3.0l193.5-199.8c56.3-58.1 53-154.3-9.8-207.9z"/></svg>&nbsp;Wakaka</div></div></footer></div><script>'serviceWorker'in navigator&&window.addEventListener('load',function(){navigator.serviceWorker.register('/sw.js')})</script></body></html>