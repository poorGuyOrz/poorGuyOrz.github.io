<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>源码阅读 on Hello Friend</title><link>https://poorguyorz.github.io/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</link><description>Recent content in 源码阅读 on Hello Friend</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Sun, 15 May 2022 21:59:53 +0800</lastBuildDate><atom:link href="https://poorguyorz.github.io/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/index.xml" rel="self" type="application/rss+xml"/><item><title>LevelDB源码阅读</title><link>https://poorguyorz.github.io/posts/readbooks/leveldb/</link><pubDate>Sun, 15 May 2022 21:59:53 +0800</pubDate><guid>https://poorguyorz.github.io/posts/readbooks/leveldb/</guid><description>
read: d019e3605f222ebc5a3a2484a2cb29db537551dd 小且完整的工业存储实现，其中有许多细节是可以借鉴的。这里没有完整的深入每一行代码，后续会时不时的慢慢补充
2022-05-17 初步阅读代码，了解组件及大致执行逻辑 编译 # git clone --recurse-submodules https://github.com/google/leveldb.git cd leveldb VSCode安装cmake插件之后，打开项目，cmake插件自动配置，此时使用shift+p设置cmake: set build target之后，再使用shift+p选择cmake: build即可编译目标模块，d019e3605f222ebc5a3a2484a2cb29db537551dd中测试文件进行了调整，全部合并到leveldb_tests中，调试时按照想要了解的模块，自己注释其他测试文件，重新编译即可。此时可以在文件中断点调试，或者使用gdb调试
slice # 字符串的浅拷贝实现，使用一个指针和指针长度实现，类似c++后来实现的string_view，如果使用string，则在传递数据的时候会进行拷贝操作，有性能损失。另一个目的是为了自主可控，确保数据在传输的过程中不会造成太多的数据副本。所以拷贝构造函数使用的是默认的系统函数，使用浅拷贝
Slice(const Slice&amp;amp;) = default; Slice&amp;amp; operator=(const Slice&amp;amp;) = default; status # 自定义信息模块，把状态码和状态信息进行压缩，压缩格式如下
Status::Status(Code code, const Slice&amp;amp; msg, const Slice&amp;amp; msg2) { assert(code != kOk); const uint32_t len1 = static_cast&amp;lt;uint32_t&amp;gt;(msg.size()); const uint32_t len2 = static_cast&amp;lt;uint32_t&amp;gt;(msg2.size()); const uint32_t size = len1 + (len2 ? (2 + len2) : 0); char* result = new char[size + 5]; std::memcpy(result, &amp;amp;size, sizeof(size)); result[4] = static_cast&amp;lt;char&amp;gt;(code); std::memcpy(result + 5, msg.</description></item></channel></rss>